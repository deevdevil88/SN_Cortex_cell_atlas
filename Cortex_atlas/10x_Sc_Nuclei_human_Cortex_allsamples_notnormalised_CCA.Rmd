---
title: "Sc_Nuclei_human Cortex samples, Seurat CCA"
author: "Devika"
date: "15th June 2018"
output: 
html_document:
  code_folding: hide
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE , cache.lazy = FALSE, tidy = TRUE)
#library(scater)
library(Matrix)
#library(DropletUtils)
library(data.table)
library(Seurat)
library(dplyr)
theme_set(theme_bw())
```

# read in the 10x data using scater
# do a QC metrics
```{r init, message=TRUE}

# load 
dir.name <- "~/Documents/10x_scN_tara_human/Samples_merged/Sample_8N5_16N5B/filtered_gene_bc_matrices_mex/GRCh38-premrna"
sce_sample_Nigra <- read10xCounts(dir.name, col.names = T)

#br.out <- barcodeRanks(counts(sce_sample_Nigra))

# Making a plot.
#plot(br.out$rank, br.out$total, log="xy", xlab="Rank", ylab="Total")
#o <- order(br.out$rank)
#lines(br.out$rank[o], br.out$fitted[o], col="red")
#abline(h=br.out$knee, col="dodgerblue", lty=2)
#abline(h=br.out$inflection, col="forestgreen", lty=2)
#legend("bottomleft", lty=2, col=c("dodgerblue", "forestgreen"), 
#legend=c("knee", "inflection"))



#set.seed(100)
#e.out <- emptyDrops(counts(sce_sample_N4_N4B))
#e.out

#is.cell <- e.out$FDR <= 0.01
#sum(is.cell, na.rm=TRUE)

samples <- read.csv(file.path("~/Documents/10x_scN_tara_human/Samples_merged/Sample_8N5_16N5B", "aggregation_csv.csv"), stringsAsFactors=F)

#cellcodes <- as.data.frame(sample_N4_N4B@raw.data@Dimnames[[2]])
#colnames(cellcodes) <- "barcodes"
#rownames(cellcodes) <- cellcodes$barcodes
#cellcodes$libcodes <- as.factor(gsub(pattern=".+-", replacement="", cellcodes$barcodes))
#cellcodes$samples <- as.vector(samples$library_id[cellcodes$libcodes])
#sampleidentity <- cellcodes["samples"]

colData(sce_sample_Nigra) <- cbind(colData(sce_sample_Nigra), sampleidentity)
#colData(sce_sample_Nigra) <- cbind(colData(sce_sample_Nigra), batches)
rownames(sce_sample_Nigra)<- rowData(sce_sample_Nigra)$Symbol

old_rowdata <- as.data.table(rowData(sce_sample_Nigra))
old_rowdata$gene <- paste(old_rowdata$ID, "-", old_rowdata$Symbol)
setnames(old_rowdata, c("ID", "gene"), c("gene", "ID"))
old_rowdata <- as.data.frame(old_rowdata)
rownames(old_rowdata) <- old_rowdata$ID
rowData(sce_sample_Nigra) <- old_rowdata


```

# find mito and ribo genes , calculate QC metrics
```{r scater_QC, message=TRUE}
rownames(sce_sample_Nigra)<- rowData(sce_sample_Nigra)$Symbol
# Find mitochondrial genes in our
# merged N4_N4B dataset
is.mito_Nigra <- grepl("^MT-", rownames(sce_sample_Nigra))

# Find ribosomal genes  grep(pattern = "^MT-", x = rownames(x = sample_N4_N4B@data), value = TRUE)
is.ribosomal_Nigra <- grepl("^RPS|^RPL",
                            rownames(sce_sample_Nigra))

rownames(sce_sample_Nigra) <- rowData(sce_sample_Nigra)$ID


# Calculate QC matrix for each cell,
# stored in pData os the SCEset
#sce_sample_N4_N4B <- calculateQCMetrics(sce_sample_N4_N4B,
                                #feature_controls = list(Rb = is.ribosomal_N4_NB,
                                                        #Mt = is.mito_N4_NB))



sce_sample_Nigra <- calculateQCMetrics(sce_sample_Nigra,
                                feature_controls = list(Rb = is.ribosomal_Nigra,
                                                        Mt = is.mito_Nigra))

#t_fdata <- rowData(sce_sample_N4_N4B)
#sum(t_fdata$n_cells_by_counts == 0)
drop_tx <- apply(counts(sce_sample_Nigra), 1, function(x) {var(x) == 0})
sce_sample_Nigra <- sce_sample_Nigra[!drop_tx, ]
cat("Genes removed with zero variance: ", sum(drop_tx), fill=T)
cat("Genes with minimal expression in at least one cell: ", dim(sce_sample_Nigra)[1], fill=T)

# Plots total genes and library sizes
#png("PlotQC_Mito_Ribo.png", w = 2000,h = 2000, res = 400)
#par(mfrow = c(2, 2), cex = 1.2)
par(mfrow=c(2,2), mar=c(6.1, 5.1, 0.1, 0.1))

hist(sce_sample_Nigra$total_counts/1e+03, xlab = "Library sizes (thousands)",
     main = "", breaks = 20, col = "grey80",
     ylab = "Number of cells")
hist(sce_sample_Nigra$total_features, xlab = "Number of expressed genes",
     main = "", breaks = 20, col = "grey80",
     ylab = "Number of cells")

# plots reads mapped to Mt genes
hist(sce_sample_Nigra$pct_counts_Mt,
     xlab = "Mitochondrial proportion (%)",
     ylab = "Number of cells", breaks = 20,
     main = "", col = "grey80")

# plots reads mapped to Rb genes
hist(sce_sample_Nigra$pct_counts_Rb,
     xlab = "Ribosomal proportion (%)",
     ylab = "Number of cells", breaks = 20,
     main = "", col = "grey80")
#dev.off()
#png("AverageCount.png", w = 2000, h = 2000,
    #res = 400)


# examine expression of log-means
 #across all genes
ave.counts <- rowMeans(counts(sce_sample_Nigra))
hist(log10(ave.counts), breaks = 100,
     main = "", col = "grey80", xlab = expression(Log[10] ~
                                                    "average count"))

rowData(sce_sample_Nigra)$ave.count <- ave.counts
to.keep <- ave.counts > 0
#sce_sample_Nigra <- sce_sample_Nigra[to.keep,]
summary(to.keep)


```

```{r , scater_gene_level_metrics, fig.height=10}
# Plot number of top genes
fontsize <- theme(axis.text = element_text(size = 8),
                  axis.title = element_text(size = 12))
#png("TopGenes_gotMapped.png", w = 2000,
    #h = 2000, res = 400)
plotQC(sce_sample_Nigra, type = "highest-expression",
       n = 50, feature_names_to_plot= "ID") + fontsize
#dev.off()

```
# look at cell level data and identifying outlies using QC metrics

```{r , scater_cell_level_metrics}
# Plot number of cells
numcells <- nexprs(sce_sample_Nigra, byrow = TRUE)
#png("AverageCount_SmoothScatter.png",
   # w = 2000, h = 2000, res = 400)
smoothScatter(log10(ave.counts), numcells,
              xlab = expression(Log[10] ~ "average count"),
              ylab = "Number of expressing cells")
#dev.off()

# PCA plot to check for potential cell
# outliers according to PC1 and PC2
# (based on general cell data)
#png("PCA_cellOutliers.png", w = 2000,
    #h = 2000, res = 400)
sce_sample_Nigra <- runPCA(sce_sample_Nigra, use_coldata = TRUE,
    detect_outliers = TRUE)

plotReducedDim(sce_sample_Nigra, use_dimred="PCA_coldata", colour_by = "samples")
#plotReducedDim(sce_sample_Nigra, use_dimred="PCA_coldata", colour_by = "batches")
#dev.off()
summary(sce_sample_Nigra$outlier)

plotQC(sce_sample_Nigra, type = "exprs-freq-vs-mean")

```



```{r , scater_pct_counts_featurecontrols}
plotColData(sce_sample_Nigra, x = "total_features_by_counts",
    y = "pct_counts_feature_control", colour_by =  "samples") +
    theme(legend.position = "top") +
    stat_smooth(method = "lm", se = FALSE, size = 2, fullrange = TRUE)

```



# removing outlier cells based on MT &RB proportion and library size
#Removal of low-quality cells is then performed by combining the filters for all of the metrics. The majority of cells are retained, which suggests that the original quality control procedures were generally adequate.

```{r}
# remove cells with low expression or
# low number of genes (lower than 3
# median absolute deviation of
# log(library size))
libsize.drop_sample <- isOutlier(sce_sample_Nigra$total_counts,
                                nmads = 3, type = "lower", log = TRUE)
feature.drop_sample <- isOutlier(sce_sample_Nigra$total_features,
                                nmads = 3, type = "lower", log = TRUE)

# remove cells with high percent of
# reads mapped to Mt genes (possibly
# dead cells) (higher than 3 median
# absolute deviation)
#not high enough to work
mito.drop_sample <- isOutlier(sce_sample_Nigra$pct_counts_feature_controls_Mt,
                             nmads = 3, type = "higher")
ribo.drop_sample <- isOutlier(sce_sample_Nigra$pct_counts_feature_controls_Rb,
                             nmads = 3, type = "higher")
sce_sample_Nigra<- sce_sample_Nigra[, !(libsize.drop_sample |
                             feature.drop_sample )]

data.frame(ByLibSize=sum(libsize.drop_sample),ByFeature=sum(feature.drop_sample), 
     Remaining=ncol(sce_sample_Nigra))



```
# further cleaning of data based on mitochondrial and RB percent of genes
```{r}
# Remove cells by Mt gene further
mito.drop0.05 <- sce_sample_Nigra$pct_counts_Mt <=
  5
mito.remove0.05 <- sce_sample_Nigra$pct_counts_Mt >
  5
sce_sample_Nigra <- sce_sample_Nigra[, mito.drop0.05]

# Remove cells by Rb gene further
ribo.drop0.05 <- sce_sample_Nigra$pct_counts_Rb <=
  5
ribo.remove0.05 <- sce_sample_Nigra$pct_counts_Rb >
  5
sce_sample_Nigra <- sce_sample_Nigra[, ribo.drop0.05]

# check number of cells that genes
# express
#png("Cells_expresing_genes.png", w = 2000,
    #h = 2000, res = 400)
numcells <- nexprs(sce_sample_Nigra, byrow = TRUE)
hist(log2(numcells), xlab = "Log2 number of cells expressing the gene",
     ylab = "Number of genes", main = "Number of cells a gene was detected")
#dev.off()

# remove genes expressed in fewer than
# 1% of total cells
numcells <- nexprs(sce_sample_Nigra, byrow = TRUE)
genes.keep <- numcells >= 12
genes.remove <- numcells < 12
sce_sample_Nigra <- sce_sample_Nigra[genes.keep,]
                               

# Plot number genes after data
# filtering
#png("TopGenes_gotMapped_PostDataCleaning.png")
#plotQC(sce_sample_N4_N4B_Ftgenes, type = "highest-expression",
      # n = 30) + fontsize
#dev.off()

plotQC(sce_sample_Nigra, type = "exprs-freq-vs-mean")



```
# cells removed numbers
```{r}
 #check how many cells are removed
datRemove <- data.frame(ByLibSize = sum(libsize.drop_sample),
                        ByFeature = sum(feature.drop_sample),
                        GeneRemovedByCell = sum(genes.remove),
                        ByMito0.05 = sum(mito.remove0.05),
                        ByRibo0.05 = sum(ribo.remove0.05),
                        CellRemaining = ncol(sce_sample_Nigra),
                        GeneRemaining = sum(genes.keep))
# feature filtering based 
keep_feature <- nexprs(sce_sample_Nigra, byrow=TRUE) >= 3
sce_sample_Nigra <- sce_sample_Nigra[keep_feature,]
dim(sce_sample_Nigra)

```


```{r , scater_cumulative_expression}
metadata <- as.data.frame(colData(sce_sample_Nigra))
plotScater(sce_sample_Nigra,
     colour_by = "samples", nfeatures = 500, exprs_values = "counts")

#plotScater(sce_sample_Nigra,
     #colour_by = "batches", nfeatures = 300, exprs_values = "counts")

```



```{r , cell_cycle_scoring_scran}
library(scran)
hs.pairs <- readRDS(system.file("exdata", "human_cycle_markers.rds", package="scran"))
# This requires the use of the Ensembl identifiers to match up with the pre-defined classifier.
rownames(sce_sample_Nigra) <- (rowData(sce_sample_Nigra)$gene)
assignments <- cyclone(sce_sample_Nigra, hs.pairs, gene.names=rowData(sce_sample_Nigra)$gene)
table(assignments$phase)
cell_cycle_phase <- as.data.frame(assignments$phases)
rownames(cell_cycle_phase) <- metadata$Barcode
metadata$Cell_Cycle <- cell_cycle_phase$`assignments$phases`
colData(sce_sample_Nigra) <- cbind(colData(sce_sample_Nigra), cell_cycle_phase)
#plotScater(sce_sample_Nigra,  block2="batches",
    # colour_by = "assignments$phases", nfeatures = 300, exprs_values = "counts")

plotScater(sce_sample_Nigra,  block2="samples",
     colour_by = "assignments$phases", nfeatures = 300, exprs_values = "counts")


```
# based on the explanantory graph from scater, will have to account for the different samples and total features

```{r experimental_factors_expression, fig.height=10}

#sizeFactors(example_sce) <- librarySizeFactors(example_sce)
#summary(sizeFactors(example_sce))
#example_sce <- normalize(example_sce)
clusters <- quickCluster(sce_sample_Nigra, min.mean=0.1, method="igraph")
sce_sample_Nigra <- computeSumFactors(sce_sample_Nigra, cluster=clusters, min.mean=0.1)
summary(sizeFactors(sce_sample_Nigra))
plot(sizeFactors(sce_sample_Nigra), sce_sample_Nigra$total_counts/1e3, log="xy",
    ylab="Library size (thousands)", xlab="Size factor")

sce_sample_Nigra<- normalize(sce_sample_Nigra)

plotQC(sce_sample_Nigra, type = "expl",
    variables = c("total_features_by_counts", "total_counts",
        "total_counts_Rb", "samples", "assignments$phases","total_counts_Mt","pct_counts_Mt","pct_counts_Rb" ,"pct_counts_feature_control", "total_features"),theme_size=12)

plotQC(sce_sample_Nigra, type = "expl", method = "pairs", theme_size = 8,variables = c("total_features_by_counts", "total_counts",
        "total_counts_Rb", "samples", "assignments$phases","total_counts_Mt","pct_counts_Mt","pct_counts_Rb" ,"pct_counts_feature_control","total_features"))
```


# important PCS for various variables for top 3000 most variable genes. As Seurat found about 3000 variable genes
# Based on these results numi,samples,percent.mito,percent.ribo, batches need to be regressed out in Seurat
```{r plots_PC_QC, fig.width=9}

sce_sample_Nigra <- runPCA(sce_sample_Nigra, ncomponents=50, ntop=2000)

plotPCA(sce_sample_Nigra, ncomponents = 2, colour_by = "samples", shape_by = "assignments$phases")

#plotPCA(sce_sample_Nigra, ncomponents = 2, colour_by = "batches", shape_by = "assignments$phases", ntop=3000)

plotQC(sce_sample_Nigra, type = "find-pcs", variable = "total_features_by_counts", ntop= 2000)

plotQC(sce_sample_Nigra, type = "find-pcs", variable = "total_counts", ntop= 2000)

plotQC(sce_sample_Nigra, type = "find-pcs", variable = "total_counts_Rb", ntop= 2000)

plotQC(sce_sample_Nigra, type = "find-pcs", variable = "samples", ntop= 2000)

#plotQC(sce_sample_Nigra, type = "find-pcs", variable = "batches", ntop= 2000)

plotQC(sce_sample_Nigra, type = "find-pcs", variable = "assignments$phases", ntop= 2000)

plotQC(sce_sample_Nigra, type = "find-pcs", variable = "total_counts_Mt", ntop=2000)

plotQC(sce_sample_Nigra, type = "find-pcs", variable = "pct_counts_Mt", ntop= 2000)

plotQC(sce_sample_Nigra, type = "find-pcs", variable = "pct_counts_Rb", ntop= 2000)

plotQC(sce_sample_Nigra, type = "find-pcs", variable = "total_features", ntop= 2000)

plotQC(sce_sample_Nigra, type = "find-pcs", variable = "pct_counts_feature_control", ntop=2000)



```



## Read in sample data and setup the Seurat Object based on the aggregation of N4 and N4B in Cell Ranger

all features in Seurat have been configured to work with sparse matrices which result in memory and speed savings for 10x data.
```{r init, message=TRUE}
library(Seurat)
library(dplyr)

# load all non-normalised or downsampled for read depth nigra samples seperately
sample_C3_data <- Read10X(data.dir = "/home/dpag0891/Documents/10x_scN_tara_human/Samples_merged/Sample_5_C3_merged/filtered_gene_bc_matrices/GRCh38-premrna")
sample_C4B_data <- Read10X(data.dir = "/home/dpag0891/Documents/10x_scN_tara_human/Samples_merged/Sample_13_C4B_merged/filtered_gene_bc_matrices/GRCh38-premrna")
sample_C5B_data <- Read10X(data.dir = "/home/dpag0891/Documents/10x_scN_tara_human/Samples_merged/Sample_15_C5B_merged/filtered_gene_bc_matrices/GRCh38-premrna")
sample_C1B_data <- Read10X(data.dir = "/home/dpag0891/Documents/10x_scN_tara_human/Samples_merged/Sample_9_C1B_merged/filtered_gene_bc_matrices/GRCh38-premrna")
sample_C2B_data <- Read10X(data.dir = "/home/dpag0891/Documents/10x_scN_tara_human/Samples_merged/Sample_11_C2B_merged/filtered_gene_bc_matrices/GRCh38-premrna")


#To modify your cell names, I would suggest changing the column names of your initial matrix. For example, to prepend 'S1_' to each of your cell names in your #initial expression matrix:

colnames(x = sample_C3_data) <- paste('C3', colnames(x = sample_C3_data), sep = '_')

colnames(x = sample_C1B_data) <- paste('C1B', colnames(x = sample_C1B_data), sep = '_')
colnames(x = sample_C2B_data) <- paste('C2B', colnames(x = sample_C2B_data), sep = '_')
colnames(x = sample_C4B_data) <- paste('C4B', colnames(x = sample_C4B_data), sep = '_')
colnames(x = sample_C5B_data) <- paste('C5B', colnames(x = sample_C5B_data), sep = '_')



# Examine the memory savings between regular and sparse matrices
#dense.size <- object.size(x = as.matrix(x = sample_Nigra_data))
#dense.size
#sparse.size <- object.size(x = sample_Nigra_data)
#sparse.size
#dense.size / sparse.size

# Also read in a list of cell cycle markers, from Tirosh et al, 2015
cc.genes <- readLines(con = "/home/dpag0891/Documents/10x_scN_tara_human/Seurat_tutorial/regev_lab_cell_cycle_genes.txt")

# We can segregate this list into markers of G2/M phase and markers of S
# phase
s.genes <- cc.genes[1:43]
g2m.genes <- cc.genes[44:97]


```

## Create a Seurat object with the filtered non-normalised data for each nigra sample


```{r create.object, results='hide', message=FALSE}
# Initialize the Seurat object with the raw (non-normalized data).
# Keep all genes expressed in >= 3 cells (~0.1% of the data). Keep all cells with at least 200 detected genes
#sample_N4_N4B<- CreateSeuratObject(raw.data = sample_N4_N4B_data, min.cells = 3, min.genes = 200, project = "10X_SN_sample_N4_N4B")
#sample_Nigra<- CreateSeuratObject(raw.data = sample_Nigra_data, min.cells = 1, min.genes =1, project = "10X_SN_sample_Nigra")
#head(x = sample_Nigra@cell.names)
#sample_Nigra <-StashIdent(sample_Nigra, save.name = "origIdent")

#samples <- read.csv(file.path("~/Documents/10x_scN_tara_human/Samples_merged/Sample_8N5_16N5B", "aggregation_csv.csv"), stringsAsFactors=F)
#samples <- read.csv(file.path("/home/dpag0891/Documents/10x_scN_tara_human/Samples_merged/Sample_7N4_14N4B", "Aggregation.csv"), stringsAsFactors=F)
#samples <- read.csv(file.path("C:/Users/Devika/Documents/10x_scN_tara_human/Samples_merged/Sample_7N4_14N4B", "Aggregation.csv"), stringsAsFactors=F)

#cellcodes <- as.data.frame(sample_Nigra@raw.data@Dimnames[[2]])
#colnames(cellcodes) <- "barcodes"
#rownames(cellcodes) <- cellcodes$barcodes
#cellcodes$libcodes <- as.factor(gsub(pattern=".+-", replacement="", cellcodes$barcodes))
#cellcodes$samples <- as.vector(samples$library_id[cellcodes$libcodes])
#cellcodes$batches <- as.factor(samples$Batch[cellcodes$libcodes])

#sampleidentity <- cellcodes["samples"]
#batches <- cellcodes["batches"]
sample_C3 <- CreateSeuratObject(raw.data = sample_C3_data, min.cells = 3, min.genes = 200, project = "sample_C3")

sample_C1B <- CreateSeuratObject(raw.data = sample_C1B_data, min.cells = 3, min.genes = 200, project = "sample_C1B")
sample_C2B <- CreateSeuratObject(raw.data = sample_C2B_data, min.cells = 3, min.genes = 200, project = "sample_C2B")
sample_C4B <- CreateSeuratObject(raw.data = sample_C4B_data, min.cells = 3, min.genes = 200, project = "sample_C4B")
sample_C5B <- CreateSeuratObject(raw.data = sample_C5B_data, min.cells = 3, min.genes = 200, project = "sample_C5B")



#sample_Nigra_negbinom<- CreateSeuratObject(raw.data = sample_Nigra_data, min.cells = 10, min.genes = 200, project = "10X_SN_sample_Nigra",meta.data =sampleidentity)
```

***

### Standard pre-processing workflow
The steps below encompass the standard pre-processing workflow for scRNA-seq data in Seurat. These represent the creation of a Seurat object, the selection and filtration of cells based on QC metrics, data normalization and scaling, and the detection of highly variable genes. In previous versions, we grouped many of these steps together in the `Setup` function, but in v2, we separate these steps into a clear and sequential workflow.


### QC and selecting cells for further analysis
While the `CreateSeuratObject` imposes a basic minimum gene-cutoff, you may want to filter out cells at this stage based on technical or biological parameters. Seurat allows you to easily explore QC metrics and filter cells based on any user-defined criteria. In the example below, we visualize gene and molecule counts, plot their relationship, and exclude cells with a clear outlier number of genes detected as potential multiplets. Of course this is not a guaranteed method to exclude cell doublets, but we include this as an example of filtering user-defined outlier cells. We also filter cells based on the percentage of mitochondrial genes present.

```{r qc, results='hide', fig.height=7,fig.width=13}
# The number of genes and UMIs (nGene and nUMI) are automatically calculated for every object by Seurat.
# For non-UMI data, nUMI represents the sum of the non-normalized values within a cell
# We calculate the percentage of mitochondrial genes here and store it in percent.mito using AddMetaData.
# We use object@raw.data since this represents non-transformed and non-log-normalized counts
# The % of UMI mapping to MT-genes is a common scRNA-seq QC metric.
mito.genes_C1B <- grep(pattern = "^MT-", x = rownames(x = sample_C1B@data), value = TRUE)

percent.mito_C1B <- Matrix::colSums(sample_C1B@raw.data[mito.genes_C1B, ]) / Matrix::colSums(sample_C1B@raw.data)

mito.genes_C2B <- grep(pattern = "^MT-", x = rownames(x = sample_C2B@data), value = TRUE)

percent.mito_C2B <- Matrix::colSums(sample_C2B@raw.data[mito.genes_C2B, ]) / Matrix::colSums(sample_C2B@raw.data)


mito.genes_C3 <- grep(pattern = "^MT-", x = rownames(x = sample_C3@data), value = TRUE)

percent.mito_C3 <- Matrix::colSums(sample_C3@raw.data[mito.genes_C3, ]) / Matrix::colSums(sample_C3@raw.data)


mito.genes_C4B <- grep(pattern = "^MT-", x = rownames(x = sample_C4B@data), value = TRUE)

percent.mito_C4B <- Matrix::colSums(sample_C4B@raw.data[mito.genes_C4B, ]) / Matrix::colSums(sample_C4B@raw.data)




mito.genes_C5B <- grep(pattern = "^MT-", x = rownames(x = sample_C5B@data), value = TRUE)

percent.mito_C5B <- Matrix::colSums(sample_C5B@raw.data[mito.genes_C5B, ]) / Matrix::colSums(sample_C5B@raw.data)

# calculate the percentage of ribosomal genes and store it in percent.ribo using ADD MEtadata
# the % of UMI mapping to Ribo genes can also be used as a QC metric


library(stringr)
#SL Ribosomal proteins 
ribo.genes_C1B <- grep(pattern = "^RP[SL][[:digit:]]", x = rownames(x = sample_C1B@data), value = TRUE)
#ribo.genes <- ribo.genes[which(str_detect(ribo.genes,"MRPL")==FALSE)]
#ribo.genes <-  ribo.genes[which(str_detect(ribo.genes,"MRPS")==FALSE)]
percent.ribo_C1B <- Matrix::colSums(sample_C1B@raw.data[ribo.genes_C1B, ])/Matrix::colSums(sample_C1B@raw.data)

ribo.genes_C2B <- grep(pattern = "^RP[SL][[:digit:]]", x = rownames(x = sample_C2B@data), value = TRUE)
#ribo.genes <- ribo.genes[which(str_detect(ribo.genes,"MRPL")==FALSE)]
#ribo.genes <-  ribo.genes[which(str_detect(ribo.genes,"MRPS")==FALSE)]
percent.ribo_C2B <- Matrix::colSums(sample_C2B@raw.data[ribo.genes_C2B, ])/Matrix::colSums(sample_C2B@raw.data)

ribo.genes_C3 <- grep(pattern = "^RP[SL][[:digit:]]", x = rownames(x = sample_C3@data), value = TRUE)
#ribo.genes <- ribo.genes[which(str_detect(ribo.genes,"MRPL")==FALSE)]
#ribo.genes <-  ribo.genes[which(str_detect(ribo.genes,"MRPS")==FALSE)]
percent.ribo_C3 <- Matrix::colSums(sample_C3@raw.data[ribo.genes_C3, ])/Matrix::colSums(sample_C3@raw.data)


ribo.genes_C4B <- grep(pattern = "^RP[SL][[:digit:]]", x = rownames(x = sample_C4B@data), value = TRUE)
#ribo.genes <- ribo.genes[which(str_detect(ribo.genes,"MRPL")==FALSE)]
#ribo.genes <-  ribo.genes[which(str_detect(ribo.genes,"MRPS")==FALSE)]
percent.ribo_C4B <- Matrix::colSums(sample_C4B@raw.data[ribo.genes_C4B, ])/Matrix::colSums(sample_C4B@raw.data)


ribo.genes_C5B <- grep(pattern = "^RP[SL][[:digit:]]", x = rownames(x = sample_C5B@data), value = TRUE)
#ribo.genes <- ribo.genes[which(str_detect(ribo.genes,"MRPL")==FALSE)]
#ribo.genes <-  ribo.genes[which(str_detect(ribo.genes,"MRPS")==FALSE)]
percent.ribo_C5B <- Matrix::colSums(sample_C5B@raw.data[ribo.genes_C5B, ])/Matrix::colSums(sample_C5B@raw.data)



# AddMetaData adds columns to object@meta.data, and is a great place to stash QC stats, add percent.mito and percent.ribo
sample_C1B<- AddMetaData(object = sample_C1B, metadata = percent.mito_C1B, col.name = "percent.mito")
sample_C1B <- AddMetaData(object = sample_C1B, metadata = percent.ribo_C1B, col.name = "percent.ribo")
sample_C1B@meta.data$sample <- "C1B"
sample_C1B@meta.data$batch <- "Day2"

sample_C2B<- AddMetaData(object = sample_C2B, metadata = percent.mito_C2B, col.name = "percent.mito")
sample_C2B <- AddMetaData(object = sample_C2B, metadata = percent.ribo_C2B, col.name = "percent.ribo")
sample_C2B@meta.data$sample <- "C2B"
sample_C2B@meta.data$batch <- "Day2"

sample_C3<- AddMetaData(object = sample_C3, metadata = percent.mito_C3, col.name = "percent.mito")
sample_C3 <- AddMetaData(object = sample_C3, metadata = percent.ribo_C3, col.name = "percent.ribo")
sample_C3@meta.data$sample <- "C3"
sample_C3@meta.data$batch <- "Day1"


sample_C4B<- AddMetaData(object = sample_C4B, metadata = percent.mito_C4B, col.name = "percent.mito")
sample_C4B <- AddMetaData(object = sample_C4B, metadata = percent.ribo_C4B, col.name = "percent.ribo")
sample_C4B@meta.data$sample <- "C4B"
sample_C4B@meta.data$batch <- "Day2"


sample_C5B<- AddMetaData(object = sample_C5B, metadata = percent.mito_C5B, col.name = "percent.mito")
sample_C5B <- AddMetaData(object = sample_C5B, metadata = percent.ribo_C5B, col.name = "percent.ribo")
sample_C5B@meta.data$sample <- "C5B"
sample_C5B@meta.data$batch <- "Day2"

#sample_Nigra <- AddMetaData(object = sample_Nigra, metadata = batches, col.name = "batches")

#sample_Nigra_negbinom<- AddMetaData(object = sample_Nigra_negbinom, metadata = percent.mito, col.name = "percent.mito")
#sample_Nigra_negbinom <- AddMetaData(object = sample_Nigra_negbinom, metadata = percent.ribo, col.name = "percent.ribo")
#sample_Nigra_negbinom <- AddMetaData(object = sample_Nigra_negbinom, metadata = batches, col.name = "batches")
```

```{r , Vln_plots}
VlnPlot(object = sample_C1B, features.plot = c("nGene", "nUMI", "percent.mito","percent.ribo"), nCol = 4)
VlnPlot(object = sample_C2B, features.plot = c("nGene", "nUMI", "percent.mito","percent.ribo"), nCol = 4)
VlnPlot(object = sample_C3, features.plot = c("nGene", "nUMI", "percent.mito","percent.ribo"), nCol = 4)
#VlnPlot(object = sample_N4, features.plot = c("nGene", "nUMI", "percent.mito","percent.ribo"), nCol = 4)
VlnPlot(object = sample_C4B, features.plot = c("nGene", "nUMI", "percent.mito","percent.ribo"), nCol = 4)
#VlnPlot(object = sample_N5, features.plot = c("nGene", "nUMI", "percent.mito","percent.ribo"), nCol = 4)
VlnPlot(object = sample_C5B, features.plot = c("nGene", "nUMI", "percent.mito","percent.ribo"), nCol = 4)


#VlnPlot(object = sample_Nigra, features.plot = c("nGene", "nUMI", "percent.mito","percent.ribo"), nCol = 4, group.by = "batches")

# GenePlot is typically used to visualize gene-gene relationships, but can be used for anything 
# calculated by the object, i.e. columns in object@meta.data, PC scores etc.
# Since there is a rare subset of cells with an outlier level of high mitochondrial percentage and hit ribosome percentage
# and also low UMI content, we filter these as well
par(mfrow = c(1, 2))
GenePlot(object = sample_C1B, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = sample_C1B, gene1 = "nUMI", gene2 = "nGene")
GenePlot(object = sample_C1B, gene1 = "nUMI", gene2 = "percent.ribo")

par(mfrow = c(1, 2))
GenePlot(object = sample_C2B, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = sample_C2B, gene1 = "nUMI", gene2 = "nGene")
GenePlot(object = sample_C2B, gene1 = "nUMI", gene2 = "percent.ribo")

par(mfrow = c(1, 2))
GenePlot(object = sample_C3, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = sample_C3, gene1 = "nUMI", gene2 = "nGene")
GenePlot(object = sample_C3, gene1 = "nUMI", gene2 = "percent.ribo")

#par(mfrow = c(1, 2))
#GenePlot(object = sample_N4, gene1 = "nUMI", gene2 = "percent.mito")
#GenePlot(object = sample_N4, gene1 = "nUMI", gene2 = "nGene")
#GenePlot(object = sample_N4, gene1 = "nUMI", gene2 = "percent.ribo")

par(mfrow = c(1, 2))
GenePlot(object = sample_C4B, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = sample_C4B, gene1 = "nUMI", gene2 = "nGene")
GenePlot(object = sample_C4B, gene1 = "nUMI", gene2 = "percent.ribo")

#par(mfrow = c(1, 2))
#GenePlot(object = sample_N5, gene1 = "nUMI", gene2 = "percent.mito")
#GenePlot(object = sample_N5, gene1 = "nUMI", gene2 = "nGene")
#GenePlot(object = sample_N5, gene1 = "nUMI", gene2 = "percent.ribo")

par(mfrow = c(1, 2))
GenePlot(object = sample_C5B, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = sample_C5B, gene1 = "nUMI", gene2 = "nGene")
GenePlot(object = sample_C5B, gene1 = "nUMI", gene2 = "percent.ribo")
```
***

***
### Normalizing the data

After removing unwanted cells from the dataset, the next step is to normalize the data. By default, we employ a global-scaling normalization method "LogNormalize" that normalizes the gene expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. 

```{r normalize, results='hide'}
# We filter out cells that have unique gene counts over 10,000 or less than 200
# Note that low.thresholds and high.thresholds are used to define a 'gate'.
# -Inf and Inf should be used if you don't want a lower or upper threshold.
sample_C1B<- FilterCells(object = sample_C1B, subset.names = c("nGene", "percent.mito", "percent.ribo"), low.thresholds = c(500, -Inf, -Inf), high.thresholds = c(5500, 0.05,0.05))

sample_C2B<- FilterCells(object = sample_C2B, subset.names = c("nGene", "percent.mito", "percent.ribo"), low.thresholds = c(500, -Inf, -Inf), high.thresholds = c(9500, 0.05,0.05))

sample_C3<- FilterCells(object = sample_C3, subset.names = c("nGene", "percent.mito", "percent.ribo"), low.thresholds = c(500, -Inf, -Inf), high.thresholds = c(12000, 0.05,0.05))

#sample_N4<- FilterCells(object = sample_N4, subset.names = c("nGene", "percent.mito", "percent.ribo"), low.thresholds = c(500, -Inf, -Inf), high.thresholds = c(7500, 0.05,0.05))

sample_C4B<- FilterCells(object = sample_C4B, subset.names = c("nGene", "percent.mito", "percent.ribo"), low.thresholds = c(500, -Inf, -Inf), high.thresholds = c(11000, 0.05,0.05))

#sample_N5<- FilterCells(object = sample_N5, subset.names = c("nGene", "percent.mito", "percent.ribo"), low.thresholds = c(500, -Inf, -Inf), high.thresholds = c(8000, 0.05,0.05))

sample_C5B<- FilterCells(object = sample_C5B, subset.names = c("nGene", "percent.mito", "percent.ribo"), low.thresholds = c(500, -Inf, -Inf), high.thresholds = c(10500, 0.05,0.05))


sample_C1B <- NormalizeData(object = sample_C1B, normalization.method = "LogNormalize", scale.factor = 1e4)
sample_C2B <- NormalizeData(object = sample_C2B, normalization.method = "LogNormalize", scale.factor = 1e4)
sample_C3 <- NormalizeData(object = sample_C3, normalization.method = "LogNormalize", scale.factor = 1e4)
#sample_N4 <- NormalizeData(object = sample_N4, normalization.method = "LogNormalize", scale.factor = 1e4)
sample_C4B <- NormalizeData(object = sample_C4B, normalization.method = "LogNormalize", scale.factor = 1e4)
#sample_N5 <- NormalizeData(object = sample_N5, normalization.method = "LogNormalize", scale.factor = 1e4)
sample_C5B <- NormalizeData(object = sample_C5B, normalization.method = "LogNormalize", scale.factor = 1e4)
#par(mfrow = c(1, 2))
#GenePlot(object = sample_Nigra, gene1 = "nUMI", gene2 = "percent.mito")
#GenePlot(object = sample_Nigra, gene1 = "nUMI", gene2 = "nGene")
#GenePlot(object = sample_Nigra, gene1 = "nUMI", gene2 = "percent.ribo")
```


```{r normalize, results='hide'}
# We filter out cells that have unique gene counts over 10,000 or less than 200
# Note that low.thresholds and high.thresholds are used to define a 'gate'.
# -Inf and Inf should be used if you don't want a lower or upper threshold.
#sample_Nigra_negbinom<- FilterCells(object = sample_Nigra_negbinom, subset.names = c("nGene", "percent.mito", "percent.ribo"), low.thresholds = c(200, -Inf, -Inf), high.thresholds = c(11000, 0.05,0.02))


#sample_Nigra_negbinom <- NormalizeData(object = sample_Nigra_negbinom, normalization.method = "LogNormalize", scale.factor = 1e4)
#par(mfrow = c(1, 2))
#GenePlot(object = sample_Nigra, gene1 = "nUMI", gene2 = "percent.mito")
#GenePlot(object = sample_Nigra, gene1 = "nUMI", gene2 = "nGene")
#GenePlot(object = sample_Nigra, gene1 = "nUMI", gene2 = "percent.ribo")
```
### Detection of variable genes across the single cells

Seurat calculates highly variable genes and focuses on these for downstream analysis. **`FindVariableGenes`** calculates the average expression and dispersion for each gene, places these genes into bins, and then calculates a z-score for dispersion within each bin. This helps control for the relationship between variability and average expression. This function is unchanged from (Macosko *et al*.), but new methods for variable gene expression identification are coming soon. We suggest that users set these parameters to mark visual outliers on the dispersion plot, but the exact parameter settings may vary based on the data type, heterogeneity in the sample, and normalization strategy. The parameters here identify ~2,000 variable genes, and represent typical parameter settings for UMI data that is normalized to a total of 1e4 molecules.

```{r var_genes, fig.height=7, fig.width=11, results='hide'}
sample_C1B <- FindVariableGenes(object = sample_C1B, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3.5, y.cutoff = 0.5)
sample_C2B <- FindVariableGenes(object = sample_C2B, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3.5, y.cutoff = 0.5)
sample_C3 <- FindVariableGenes(object = sample_C3, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3.5, y.cutoff = 0.5)
#sample_N4 <- FindVariableGenes(object = sample_N4, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3.0, y.cutoff = 0.5)
sample_C4B <- FindVariableGenes(object = sample_C4B, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3.5, y.cutoff = 0.5)
#sample_N5 <- FindVariableGenes(object = sample_N5, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3.0, y.cutoff = 0.5)
sample_C5B <- FindVariableGenes(object = sample_C5B, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3.5, y.cutoff = 0.5)


```

```{r var_genes, fig.height=7, fig.width=11, results='hide'}
#sample_Nigra_negbinom<- FindVariableGenes(object = sample_Nigra_negbinom, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3.0, y.cutoff = 0.5,y.high.cutoff =16 )
```

```{r len_var_genes}
length(x = sample_C1B@var.genes)
length(x = sample_C2B@var.genes)
length(x = sample_C3@var.genes)
#length(x = sample_N4@var.genes)
length(x = sample_C4B@var.genes)
#length(x = sample_N5@var.genes)
length(x = sample_C5B@var.genes)
```


***

### Scaling the data and removing unwanted sources of variation

Your single cell dataset likely contains 'uninteresting' sources of variation. This could include not only technical noise, but batch effects, or even biological sources of variation (cell cycle stage). As suggested in [Buettner *et al*, NBT, 2015](https://www.nature.com/articles/nbt.3102), regressing these signals out of the analysis can improve downstream dimensionality reduction and clustering. To mitigate the effect of these signals, Seurat constructs linear models to predict gene expression based on user-defined variables. The scaled z-scored residuals of these models are stored in the scale.data slot, and  are used for dimensionality reduction and clustering. 

We can regress out cell-cell variation in gene expression driven by batch (if applicable), cell alignment rate (as provided by Drop-seq tools for Drop-seq data),  the number of detected molecules, and mitochondrial gene expression. For cycling cells, we can also learn a 'cell-cycle' score (see example [here](http://satijalab.org/seurat/cell_cycle_vignette.html)) and regress this out as well. In this simple example here for post-mitotic blood cells, we regress on the number of detected molecules per cell as well as the percentage mitochondrial gene content.  

Seurat v2.0 implements this regression as part of the data scaling process. Therefore, the `RegressOut` function has been deprecated, and replaced with the vars.to.regress argument in `ScaleData`.

regress out the technical factors (nUMI, percent.ribo, percent.mito)
look to see if cell cycle needs to be regressed and then regress that out

```{r regress, fig.height=7, fig.width=11, results='hide'}

sample_C1B <- ScaleData(object = sample_C1B,vars.to.regress = c("nUMI", "percent.mito", "percent.ribo"), model.use = "linear", do.par = T)
sample_C2B <- ScaleData(object = sample_C2B,vars.to.regress = c("nUMI", "percent.mito", "percent.ribo"), model.use = "linear", do.par = T)
sample_C3 <- ScaleData(object = sample_C3,vars.to.regress = c("nUMI", "percent.mito", "percent.ribo"), model.use = "linear", do.par = T)
#sample_N4 <- ScaleData(object = sample_N4,vars.to.regress = c("nUMI", "percent.mito", "percent.ribo"), model.use = "linear", do.par = T)
sample_C4B <- ScaleData(object = sample_C4B,vars.to.regress = c("nUMI", "percent.mito", "percent.ribo"), model.use = "linear", do.par = T)
#sample_N5 <- ScaleData(object = sample_C5,vars.to.regress = c("nUMI", "percent.mito", "percent.ribo"), model.use = "linear", do.par = T)
sample_C5B <- ScaleData(object = sample_C5B,vars.to.regress = c("nUMI", "percent.mito", "percent.ribo"), model.use = "linear", do.par = T)


#sample_Nigra_negbinom <- ScaleData(object = sample_Nigra_negbinom,vars.to.regress = c("nUMI","samples", "percent.mito", "percent.ribo"), model.use = "negbinom")
```

```{r sample_identity_PCA  fig.height=10, fig.width=8, warning=FALSE}
sample_C1B <- RunPCA(object = sample_C1B, pc.genes = sample_C1B@var.genes, do.print = T, pcs.compute = 60)
sample_C2B <- RunPCA(object = sample_C2B, pc.genes = sample_C2B@var.genes, do.print = T, pcs.compute = 60)
sample_C3 <- RunPCA(object = sample_C3, pc.genes = sample_C3@var.genes, do.print = T, pcs.compute = 60)
#sample_N4 <- RunPCA(object = sample_C4, pc.genes = sample_C4@var.genes, do.print = T, pcs.compute = 50)
sample_C4B <- RunPCA(object = sample_C4B, pc.genes = sample_C4B@var.genes, do.print = T, pcs.compute = 60)
#sample_N5 <- RunPCA(object = sample_N5, pc.genes = sample_N5@var.genes, do.print = T, pcs.compute = 50)
sample_C5B <- RunPCA(object = sample_C5B, pc.genes = sample_C5B@var.genes, do.print = T, pcs.compute = 60)

#PCA plot to see if sample idenitity has an effect on PCA
#PCAPlot(object = sample_Nigra, group.by="samples")
#PCAPlot(object = sample_Nigra, dim.1=2,dim.2=3, group.by="samples")
#PCAPlot(object = sample_Nigra, dim.1=1,dim.2=3, group.by="samples")
#PCAPlot(object = sample_Nigra, dim.1=4,dim.2=5, group.by="samples")
#PCAPlot(object = sample_Nigra, dim.1=5,dim.2=6, group.by="samples")
#PCAPlot(object = sample_Nigra, group.by="samples")
#PCAPlot(object = sample_Nigra, dim.1=2,dim.2=3, group.by="batches")
#PCAPlot(object = sample_Nigra, dim.1=1,dim.2=3, group.by="batches")
#PCAPlot(object = sample_Nigra, dim.1=4,dim.2=5, group.by="batches")
#PCAPlot(object = sample_Nigra, dim.1=5,dim.2=6, group.by="batches")
#based on PCA , aggregated, read-depth normalised samples dont seperate by sample identities after regressing out sample effect
```



****


Assign Cell-Cycle Scores
First, we assign each cell a score, based on its expression of G2/M and S phase markers. These marker sets should be anticorrelated in their expression levels, and cells expressing neither are likely not cycling and in G1 phase.

We assign scores in the CellCycleScoring function, which stores S and G2/M scores in object@meta.data, along with the predicted classification of each cell in either G2M, S or G1 phase. CellCycleScoring can also set the identity of the Seurat object to the cell-cycle phase by passing set.ident = TRUE (the original identities are stored as old.ident). Please note that Seurat does not use the discrete classifications (G2M/G1/S) in downstream cell cycle regression. Instead, it uses the quantitative scores for G2M and S phase. However, we provide our predicted classifications in case they are of interest.


```{r cell_cycle_scores, fig.height=6, fig.width=8, warning=FALSE}


sample_C1B <- CellCycleScoring(object = sample_C1B, s.genes = s.genes, g2m.genes = g2m.genes, 
    set.ident = TRUE)
sample_C2B <- CellCycleScoring(object = sample_C2B, s.genes = s.genes, g2m.genes = g2m.genes, 
    set.ident = TRUE)
sample_C3 <- CellCycleScoring(object = sample_C3, s.genes = s.genes, g2m.genes = g2m.genes, 
    set.ident = TRUE)
#sample_N4 <- CellCycleScoring(object = sample_N4, s.genes = s.genes, g2m.genes = g2m.genes, 
 #   set.ident = TRUE)
sample_C4B <- CellCycleScoring(object = sample_C4B, s.genes = s.genes, g2m.genes = g2m.genes, 
    set.ident = TRUE)
#sample_N5 <- CellCycleScoring(object = sample_N5, s.genes = s.genes, g2m.genes = g2m.genes, 
 #   set.ident = TRUE)
sample_C5B <- CellCycleScoring(object = sample_C5B, s.genes = s.genes, g2m.genes = g2m.genes, 
    set.ident = TRUE)

# view cell cycle scores and phase assignments
#head(x = sample_Nigra@meta.data)
# export metadata as dataframe to use cell cycle phasing for scater
#seurat_metadata <- sample_N4_N4B@meta.data
# Visualize the distribution of ribosome genes across
#RidgePlot(object = sample_5_c3, features.plot = c("RPL22","RPL11"),nCol =2)
# Running a PCA on cell cycle genes reveals that cells dont seperate by cell cycle pphase at all, but heatamp showes there is some effect)

PCAPlot(object = sample_C1B)
PCAPlot(object = sample_C1B, dim.1=2,dim.2=3)
PCAPlot(object = sample_C1B, dim.1=1,dim.2=3)

PCAPlot(object = sample_C2B)
PCAPlot(object = sample_C2B, dim.1=2,dim.2=3)
PCAPlot(object = sample_C2B, dim.1=1,dim.2=3)

PCAPlot(object = sample_C3)
PCAPlot(object = sample_C3, dim.1=2,dim.2=3)
PCAPlot(object = sample_C3, dim.1=1,dim.2=3)

#PCAPlot(object = sample_N4)
#PCAPlot(object = sample_N4, dim.1=2,dim.2=3)
#PCAPlot(object = sample_N4, dim.1=1,dim.2=3)

PCAPlot(object = sample_C4B)
PCAPlot(object = sample_C4B, dim.1=2,dim.2=3)
PCAPlot(object = sample_C4B, dim.1=1,dim.2=3)

#PCAPlot(object = sample_N5)
#PCAPlot(object = sample_N5, dim.1=2,dim.2=3)
#PCAPlot(object = sample_N5, dim.1=1,dim.2=3)

PCAPlot(object = sample_C5B)
PCAPlot(object = sample_C5B, dim.1=2,dim.2=3)
PCAPlot(object = sample_C5B, dim.1=1,dim.2=3)
```




# PC HEatmap to see if cell cycle genes seperate the PCAs
```{r, PC_Heatmap,fig.height= 20, fig.width=8}
#PCHeatmap(object = sample_Nigra, pc.use = 1:15, do.balanced = TRUE, label.columns = FALSE, 
    #remove.key = TRUE)
RidgePlot(object = sample_C1B, features.plot = c("PCNA", "TOP2A", "MCM6", "NUSAP1", "PRC1", "PLK1", "KIF11", "TYMS","TPX2", "HMGB2", "CCNB2"), 
    nCol = 2)
RidgePlot(object = sample_C2B, features.plot = c("PCNA", "TOP2A", "MCM6", "NUSAP1", "PRC1", "PLK1", "KIF11", "TYMS","TPX2", "CDK1", "CCNB2"), 
    nCol = 2)
RidgePlot(object = sample_C3, features.plot = c("PCNA", "TOP2A", "MCM6", "NUSAP1", "PRC1", "PLK1", "KIF11", "TYMS","TPX2", "CDK1", "CCNB2"), 
    nCol = 2)
#RidgePlot(object = sample_N4, features.plot = c("PCNA", "KIF2C", "MCM6", "NUSAP1", "PRC1", "PLK1", "KIF11", "TYMS","CENPA", "HMGB2", "CCNB2"), 
 #   nCol = 2)
#RidgePlot(object = sample_N5, features.plot = c("PCNA", "KIF2C", "MCM6", "NUSAP1", "PRC1", "PLK1", "KIF11", "TYMS","CENPA", "HMGB2", "CCNB2"), 
 #   nCol = 2)
RidgePlot(object = sample_C4B, features.plot = c("PCNA", "KIF2C", "MCM6", "NUSAP1", "PRC1", "PLK1", "KIF11", "TYMS","CENPA", "CDK1", "TMPO"), 
    nCol = 2)
RidgePlot(object = sample_C5B, features.plot = c("PCNA", "KIF2C", "MCM6", "NUSAP1", "PRC1", "PLK1", "KIF11", "TYMS","CENPA", "CDK1", "TMPO"), 
    nCol = 2)
```

```{r cell_cycle_genes_pca }
# check to see if cell seperate by the percent of ribogenes, which they do.
#sample_5_c3 <- RunPCA(object = sample_5_c3, pc.genes = ribo.genes, do.print = T)
#PCAPlot(object = sample_5_c3)
# Running a PCA on cell cycle genes reveals, unsurprisingly, that cells
# separate entirely by phase # not in my case
sample_C1B <- RunPCA(object = sample_C1B, pc.genes = c(s.genes, g2m.genes), do.print = FALSE)
PCAPlot(object = sample_C1B)
PCAPlot(object = sample_C1B, dim.1=2,dim.2=3)
PCAPlot(object = sample_C1B, dim.1=1,dim.2=3)
PCAPlot(object = sample_C1B, dim.1=4,dim.2=5)
PCAPlot(object = sample_C1B, dim.1=5,dim.2=6)

sample_C2B <- RunPCA(object = sample_C2B, pc.genes = c(s.genes, g2m.genes), do.print = FALSE)
PCAPlot(object = sample_C2B)
PCAPlot(object = sample_C2B, dim.1=2,dim.2=3)
PCAPlot(object = sample_C2B, dim.1=1,dim.2=3)
PCAPlot(object = sample_C2B, dim.1=4,dim.2=5)
PCAPlot(object = sample_C2B, dim.1=5,dim.2=6)

sample_C3 <- RunPCA(object = sample_C3, pc.genes = c(s.genes, g2m.genes), do.print = FALSE)
PCAPlot(object = sample_C3)
PCAPlot(object = sample_C3, dim.1=2,dim.2=3)
PCAPlot(object = sample_C3, dim.1=1,dim.2=3)
PCAPlot(object = sample_C3, dim.1=4,dim.2=5)
PCAPlot(object = sample_C3, dim.1=5,dim.2=6)

#sample_N4 <- RunPCA(object = sample_N4, pc.genes = c(s.genes, g2m.genes), do.print = FALSE)
#PCAPlot(object = sample_N4)
#PCAPlot(object = sample_N4, dim.1=2,dim.2=3)
#PCAPlot(object = sample_N4, dim.1=1,dim.2=3)
#PCAPlot(object = sample_N4, dim.1=4,dim.2=5)
#PCAPlot(object = sample_N4, dim.1=5,dim.2=6)

#sample_N5 <- RunPCA(object = sample_N5, pc.genes = c(s.genes, g2m.genes), do.print = FALSE)
#PCAPlot(object = sample_N5)
#PCAPlot(object = sample_N5, dim.1=2,dim.2=3)
#PCAPlot(object = sample_N5, dim.1=1,dim.2=3)
#PCAPlot(object = sample_N5, dim.1=4,dim.2=5)
#PCAPlot(object = sample_N5, dim.1=5,dim.2=6)

sample_C4B <- RunPCA(object = sample_C4B, pc.genes = c(s.genes, g2m.genes), do.print = FALSE)
PCAPlot(object = sample_C4B)
PCAPlot(object = sample_C4B, dim.1=2,dim.2=3)
PCAPlot(object = sample_C4B, dim.1=1,dim.2=3)
PCAPlot(object = sample_C4B, dim.1=4,dim.2=5)
PCAPlot(object = sample_C4B, dim.1=5,dim.2=6)

sample_C5B <- RunPCA(object = sample_C5B, pc.genes = c(s.genes, g2m.genes), do.print = FALSE)
PCAPlot(object = sample_C5B)
PCAPlot(object = sample_C5B, dim.1=2,dim.2=3)
PCAPlot(object = sample_C5B, dim.1=1,dim.2=3)
PCAPlot(object = sample_C5B, dim.1=4,dim.2=5)
PCAPlot(object = sample_C5B, dim.1=5,dim.2=6)


```

#As not much effect of cell cycle genes seen in seurat and scater
# not regressing it out
```{r PCHeatmap_cell_cycle_genes, fig.height=20 , fig.width=15}
PCHeatmap(object = sample_C1B, pc.use = 1:20, do.balanced = TRUE, label.columns = FALSE, remove.key = TRUE)
PCHeatmap(object = sample_C2B, pc.use = 1:20, do.balanced = TRUE, label.columns = FALSE, remove.key = TRUE)
PCHeatmap(object = sample_C3, pc.use = 1:20, do.balanced = TRUE, label.columns = FALSE, remove.key = TRUE)
#PCHeatmap(object = sample_N4, pc.use = 1:20, do.balanced = TRUE, label.columns = FALSE, remove.key = TRUE)
PCHeatmap(object = sample_C4B, pc.use = 1:20, do.balanced = TRUE, label.columns = FALSE, remove.key = TRUE)
#PCHeatmap(object = sample_N5, pc.use = 1:20, do.balanced = TRUE, label.columns = FALSE, remove.key = TRUE)
PCHeatmap(object = sample_C5B, pc.use = 1:20, do.balanced = TRUE, label.columns = FALSE, remove.key = TRUE)
# regress out cell cycle effect to the already regressed dataset for variables(nUMI,percent.mito,percent.ribo)
```

##regress out cell cycle score on already scaled and regressed out data for numi, ribo.percent, mito.percent
Regress out cell cycle scores during data scaling
We now attempt to subtract ('regress out') this source of heterogeneity from the data. For users of Seurat v1.4, this was implemented in RegressOut. However, as the results of this procedure are stored in object@scale.data (therefore overwriting the output of ScaleData), we now merge this functionality into the ScaleData function itself.

For each gene, Seurat models the relationship between gene expression and the S and G2M cell cycle scores. The scaled residuals of this model represent a 'corrected' expression matrix, that can be used downstream for dimensional reduction

no need to regress out cell cycle phases

### Perform linear dimensional reduction

Next we perform PCA on the scaled data. By default, the genes in `object@var.genes` are used as input, but can be defined using pc.genes. We have typically found that running dimensionality reduction on highly variable genes can improve performance. However, with UMI data - particularly after regressing out technical variables, we often see that PCA returns similar (albeit slower) results when run on much larger subsets of genes, including the whole transcriptome.
```{r pca}
#sample_6_n3 <- ScaleData(object = sample_6_n3, data.use = sample_6_n3@scale.data, vars.to.regress = c("S.Score", "G2M.Score"))
sample_C1B<- RunPCA(object = sample_C1B, pc.genes = sample_C1B@var.genes, do.print = TRUE, pcs.print = 1:6, genes.print = 10, pcs.compute = 60)
sample_C2B<- RunPCA(object = sample_C2B, pc.genes = sample_C2B@var.genes, do.print = TRUE, pcs.print = 1:6, genes.print = 10, pcs.compute = 60)
sample_C3<- RunPCA(object = sample_C3, pc.genes = sample_C3@var.genes, do.print = TRUE, pcs.print = 1:6, genes.print = 10, pcs.compute = 60)
#sample_N4<- RunPCA(object = sample_N4, pc.genes = sample_N4@var.genes, do.print = TRUE, pcs.print = 1:6, genes.print = 10, pcs.compute = 60)
sample_C4B <- RunPCA(object = sample_C4B, pc.genes = sample_C4B@var.genes, do.print = TRUE, pcs.print = 1:6, genes.print = 10, pcs.compute = 60)
#sample_N5 <- RunPCA(object = sample_N5, pc.genes = sample_N5@var.genes, do.print = TRUE, pcs.print = 1:6, genes.print = 10, pcs.compute = 60)
sample_C5B <- RunPCA(object = sample_C5B, pc.genes = sample_C5B@var.genes, do.print = TRUE, pcs.print = 1:6, genes.print = 10, pcs.compute = 60)
```

```{r pca, fig.height=12}
 library(RColorBrewer)
col.pal <- RColorBrewer::brewer.pal(9,name= "Blues")

PCHeatmap(object = sample_C1B, pc.use = 1:6, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, use.full = FALSE, col.use = col.pal)
PCHeatmap(object = sample_C2B, pc.use = 1:6, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, use.full = FALSE, col.use = col.pal)
PCHeatmap(object = sample_C3, pc.use = 1:6, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, use.full = FALSE, col.use = col.pal)
#PCHeatmap(object = sample_C4, pc.use = 1:6, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, use.full = FALSE, col.use = col.pal)
#PCHeatmap(object = sample_N5, pc.use = 1:6, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, use.full = FALSE, col.use = col.pal)
PCHeatmap(object = sample_C5B, pc.use = 1:6, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, use.full = FALSE, col.use = col.pal)
PCHeatmap(object = sample_C4B, pc.use = 1:6, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, use.full = FALSE, col.use = col.pal)
#sample_6_n3 <- ScaleData(object = sample_6_n3, data.use = sample_6_n3@scale.data, vars.to.regress = c("S.Score", "G2M.Score"))
#sample_Nigra_negbinom<- RunPCA(object = sample_Nigra_negbinom, pc.genes = sample_Nigra_negbinom@var.genes, do.print = TRUE, pcs.print = 1:6, genes.print = 20, pcs.compute = 50)
```



# find the union of a minimum of 3500 genes between the samples (~3500 minimum var genes value in one sample)
```{r union_var_genes_samples}
# Determine genes to use for CCA, must be highly variable in at least 4 datasets
ob.list <- list(sample_C1B, sample_C2B, sample_C3,sample_C4B,sample_C5B)
genes.use <- c()
for (i in 1:length(ob.list)) {
  genes.use <- c(genes.use, head(rownames(ob.list[[i]]@hvg.info), 3500))
}
genes.use <- names(which(table(genes.use) >= 3))
for (i in 1:length(ob.list)) {
  genes.use <- genes.use[genes.use %in% rownames(ob.list[[i]]@scale.data)]
}
```

#RUN multiCCA
```{r}
# Run multi-set CCA
Cortex.integrated <- RunMultiCCA(ob.list, genes.use = genes.use, num.ccs = 60, niter=1000)
```


```{r, fig.width=15, fig.height=8}
# visualize results of CCA plot CC1 versus CC2 and look at a violin plot
p1 <- DimPlot(object = Cortex.integrated, reduction.use = "cca", group.by = "sample", 
    pt.size = 0.5, do.return = TRUE)
p2 <- VlnPlot(object = Cortex.integrated, features.plot = "CC1", group.by = "sample", 
    do.return = TRUE)
plot_grid(p1, p2)

p1 <- DimPlot(object = Cortex.integrated, reduction.use = "cca", group.by = "batch", 
    pt.size = 0.5, do.return = TRUE)
p2 <- VlnPlot(object = Cortex.integrated, features.plot = "CC1", group.by = "batch", 
    do.return = TRUE)
plot_grid(p1, p2)
```


```{r}
PrintDim(object = Cortex.integrated, reduction.type = "cca", dims.print = 1:2, 
    genes.print = 20)
```
#The problem of choosing CCs for downstream analysis such as clustering is analogous to that of choosing PCs and we provide similar functions for exploring which CCs to include. When choosing PCs, often we look for a saturation in the relationship between the number of principle components and the percentage of the variance explained. Here, we provide  MetageneBicorPlot, which examines a measure of correlation strength for each CC and find that this statistic generally saturates after a reasonable number of CCs. 

```{r}
# CC Selection
MetageneBicorPlot(Cortex.integrated, grouping.var = "sample", dims.eval = 1:60)
MetageneBicorPlot(Cortex.integrated, grouping.var = "batch", dims.eval = 1:60)
```

# based on the Bicor Plot chose CCs 1:42
# look at the heatmaps of the Dims to see if they seperate ok and visualise the genes
```{r,fig.width=10, fig.height=10}
DimHeatmap(Cortex.integrated, reduction.type = "cca", cells.use = 500, dim.use = 1:9, do.balanced = T)
DimHeatmap(Cortex.integrated, reduction.type = "cca", cells.use = 500, dim.use = 10:18, do.balanced = T)
DimHeatmap(Cortex.integrated, reduction.type = "cca", cells.use = 500, dim.use = 19:28, do.balanced = T)
DimHeatmap(Cortex.integrated, reduction.type = "cca", cells.use = 500, dim.use = 29:38, do.balanced = T)
DimHeatmap(Cortex.integrated, reduction.type = "cca", cells.use = 500, dim.use = 39:48, do.balanced = T)
```
#Before we align the subspaces, we first search for cells whose expression profile cannot be 
#well-explained by low-dimensional CCA, compared to low-dimensional PCA.


```{r, fig.height=8, fig.width=15}


# Run rare non-overlapping filtering
Cortex.integrated <- CalcVarExpRatio(object = Cortex.integrated, reduction.type = "pca",
                                       grouping.var = "sample", dims.use = 1:42)

# We discard cells where the variance explained by CCA is <2-fold  (ratio < 0.5) compared to PCA
Cortex.integrated.all.save <- Cortex.integrated
Cortex.integrated <- SubsetData(Cortex.integrated, subset.name = "var.ratio.pca",
                                           accept.low = 0.5)
# discarded cells
Cortex.discard <- SubsetData(Cortex.integrated.all.save, subset.name = "var.ratio.pca", accept.high = 0.5)


# Alignment
Cortex.integrated <- AlignSubspace(Cortex.integrated,
                                     reduction.type = "cca",
                                     grouping.var = "sample",
                                     dims.align = 1:42)

```

```{r, fig.width=15, fig.height=8}
#We can visualize the aligned CCA and perform an integrated analysis.

p1 <- DimPlot(object = Cortex.integrated, reduction.use = "cca.aligned", group.by = "sample", 
    pt.size = 0.5, do.return = TRUE)
p2 <- DimPlot(object = Cortex.integrated, reduction.use = "cca.aligned", group.by = "sample", 
    pt.size = 0.5, do.return = TRUE, dim.1 = 2, dim.2=3)
p3 <- DimPlot(object = Cortex.integrated, reduction.use = "cca.aligned", group.by = "sample", 
    pt.size = 0.5, do.return = TRUE, dim.1 = 3, dim.2=4)
plot_grid(p1, p2)
plot_grid(p2, p3)

p1 <- DimPlot(object = Cortex.integrated, reduction.use = "cca.aligned", group.by = "batch", 
    pt.size = 0.5, do.return = TRUE)
p2 <- DimPlot(object = Cortex.integrated, reduction.use = "cca.aligned", group.by = "batch", 
    pt.size = 0.5, do.return = TRUE, dim.1 = 2, dim.2=3)
p3 <- DimPlot(object = Cortex.integrated, reduction.use = "cca.aligned", group.by = "batch", 
    pt.size = 0.5, do.return = TRUE, dim.1 = 3, dim.2=4)
plot_grid(p1, p2)
plot_grid(p2,p3)

p1 <- VlnPlot(object = Cortex.integrated, features.plot = "ACC1", group.by = "sample", 
    do.return = TRUE)
p2 <- VlnPlot(object = Cortex.integrated, features.plot = "ACC2", group.by = "sample", 
    do.return = TRUE)
p3 <- VlnPlot(object = Cortex.integrated, features.plot = "ACC3", group.by = "sample", 
    do.return = TRUE)
plot_grid(p1, p2)
plot_grid(p2,p3)

p1 <- VlnPlot(object = Cortex.integrated, features.plot = "ACC1", group.by = "batch", 
    do.return = TRUE)
p2 <- VlnPlot(object = Cortex.integrated, features.plot = "ACC2", group.by = "batch", 
    do.return = TRUE)
p3 <- VlnPlot(object = Cortex.integrated, features.plot = "ACC3", group.by = "batch", 
    do.return = TRUE)
plot_grid(p1, p2)
plot_grid(p2, p3)
```

```{r}
# t-SNE and Clustering
Cortex.integrated <- FindClusters(Cortex.integrated, reduction.type = "cca.aligned",
                                    dims.use = 1:42, save.SNN = T, resolution = 0.8, n.iter = 1000, n.start = 1000)
Cortex.integrated <- RunTSNE(Cortex.integrated,
                               reduction.use = "cca.aligned",
                               dims.use = 1:42, do.fast=T)


```




```{r}
PrintFindClustersParams(object = Cortex.integrated, resolution = 0.8)
Nigra.integrated <- SetAllIdent(Cortex.integrated, id = "res_0.8")
```

```{r, fig.width=15, fig.height=6}
# Visualization
p1 <- TSNEPlot(Cortex.integrated, group.by = "sample", do.return = T, pt.size = 0.5)
p2 <- TSNEPlot(Cortex.integrated, do.return = T, pt.size = 0.5, do.label = T)
plot_grid(p1, p2)

p1 <- TSNEPlot(Cortex.integrated, group.by = "batch", do.return = T, pt.size = 0.5)
p2 <- TSNEPlot(Cortex.integrated, do.return = T, pt.size = 0.5, do.label = T)
plot_grid(p1, p2)
```


```{r}
Cortex.integrated@meta.data$full.ident <- paste(Cortex.integrated@meta.data$res.0.8, Cortex.integrated@meta.data$sample, sep = "_")
```


```{r, fig.width=10}
# Calculate number of cells per cluster from object@ident
cell.num <- table(Cortex.integrated@meta.data$res.0.8)

# Add cell number per cluster to cluster labels
ClusterLabels = paste("Cluster",names(cell.num), paste0("(n = ", cell.num, ")"))

# Order legend labels in plot in the same order as 'ClusterLabels'
ClusterBreaks = names(cell.num)
colourCount = length(cell.num)
library(RColorBrewer)
getPalette = colorRampPalette(brewer.pal(9, "Set1"))
# Plot tSNE with new legend labels for clusters
TSNEPlot(object = Cortex.integrated, do.return = T,  pt.size = 0.8) +
  scale_colour_manual(breaks = ClusterBreaks, 
                        labels = ClusterLabels, values=getPalette(colourCount)) +
  labs(x = "t-SNE 1",
       y = "t-SNE 2")

```

#sample numbers for TSNE plot

```{r, fig.width=12}
# Calculate number of cells per cluster from object@ident
library(RColorBrewer)
cell.num <- table(Cortex.integrated@meta.data$sample)

# Add cell number per cluster to cluster labels
ClusterLabels = paste("Sample",names(cell.num), paste0("(n = ", cell.num, ")"))

# Order legend labels in plot in the same order as 'ClusterLabels'
ClusterBreaks = names(cell.num)
colourCount = length(cell.num)
getPalette = colorRampPalette(brewer.pal(9, "Set1"))
# Plot tSNE with new legend labels for clusters
TSNEPlot(object = Cortex.integrated, do.return = T,  pt.size = 0.8, group.by="sample") +
  scale_colour_manual(breaks = ClusterBreaks, 
                        labels = ClusterLabels, values=getPalette(colourCount)) +
  labs(x = "t-SNE 1",
       y = "t-SNE 2")

```




# colour clusters with nUMI and nGene as well

```{r}
Cortex.integrated_tSNE <- as.data.frame(Cortex.integrated@dr$tsne@cell.embeddings)
Cortex.integrated_tSNE$nUMI <- Cortex.integrated@meta.data$nUMI
Cortex.integrated_tSNE$nGene <- Cortex.integrated@meta.data$nGene
```

```{r,fig.height=6, fig.width=9}
library(RColorBrewer)
ggplot(Cortex.integrated_tSNE, aes(x= tSNE_1, y=tSNE_2)) +  
  geom_point(size=0.8, aes(colour=nUMI)) +
   theme_bw(base_size=12)+
  scale_color_gradientn(colors = brewer.pal(11,"Spectral"),limits=c(500,75000), guide = "colourbar")

ggplot(Cortex.integrated_tSNE, aes(x= tSNE_1, y=tSNE_2)) +  
  geom_point(size=0.8, aes(colour=nGene)) +
   theme_bw(base_size=12)+
  scale_color_gradientn(colors = brewer.pal(11,"Spectral"),limits=c(500,12000), guide = "colourbar")
```





# Identify conserved cell type markers for each cluster across individuals
```{r}
cluster0.markers <- FindConservedMarkers(Nigra.integrated, ident.1 = 0, grouping.var = "sample", test.use="negbinom",
    print.bar = T)
cluster1.markers <- FindConservedMarkers(Nigra.integrated, ident.1 = 1, grouping.var = "sample", test.use="negbinom",
    print.bar = T)
cluster2.markers <- FindConservedMarkers(Nigra.integrated, ident.1 = 2, grouping.var = "batch", test.use="negbinom",
    print.bar = T)
cluster3.markers <- FindConservedMarkers(Nigra.integrated, ident.1 = 3, grouping.var = "sample", test.use="negbinom",
    print.bar = T)
cluster4.markers <- FindConservedMarkers(Nigra.integrated, ident.1 = 4, grouping.var = "sample", test.use="negbinom",
    print.bar = T)
cluster5.markers <- FindConservedMarkers(Nigra.integrated, ident.1 = 5, grouping.var = "batch", test.use="negbinom",
    print.bar = T)
cluster6.markers <- FindConservedMarkers(Nigra.integrated, ident.1 = 6, grouping.var = "sample", test.use="negbinom",
    print.bar = T)
#cluster7.markers <- FindConservedMarkers(Nigra.integrated, ident.1 = 7, test.use="negbinom",
    #print.bar = T)
cluster8.markers <- FindConservedMarkers(Nigra.integrated, ident.1 = 8, grouping.var = "sample", test.use="negbinom",
    print.bar = T)
head(nk.markers)
```


```{r}

Cortex_0.8_clustermarkers <-  FindAllMarkers(object = Cortex.integrated, only.pos = T, min.pct = 0.25, thresh.use = 0.25, test.use="negbinom", logfc.threshold = 0.25)
write.table(Cortex_0.8_clustermarkers, file="./Cortex_0.8_DEG_clusters_2019.txt",sep="\t",quote=F)
save.image("./10x_Sc_Nuclei_human_Cortex_allsamples_notnormalised_CCA.RData")


#Nigra_0.4_clustermarkers_1 <- unique(Nigra_0.4_clustermarkers$gene)
```

# use neuroexpresso to get cell type marker lists. Originally from mouse for different brain regions.

```{r celltype_markers, fig.height=8, fig.width=15,}
devtools::install_github('oganm/markerGeneProfile')
library(markerGeneProfile)
library(viridis)
mouse_marker_genes <- data(mouseMarkerGenes)

Cortex_astrocyte = mouseMarkerGenes$Cortex$Astrocyte %>% homologene::mouse2human()
Cortex_endothelial = mouseMarkerGenes$Cortex$Endothelial %>% homologene::mouse2human()
Cortex_GabaPV = mouseMarkerGenes$Cortex$GabaPV %>% homologene::mouse2human()
Cortex_GabaRelnCalb = mouseMarkerGenes$Cortex$GabaRelnCalb %>% homologene::mouse2human()
Cortex_GabaVIPReln = mouseMarkerGenes$Cortex$GabaVIPReln %>% homologene::mouse2human()
Cortex_Microglia = mouseMarkerGenes$Cortex$Microglia %>% homologene::mouse2human()
Cortex_Microglia_activation = mouseMarkerGenes$Cortex$Microglia_activation %>% homologene::mouse2human()
Cortex_Microglia_deactivation = mouseMarkerGenes$Cortex$Microglia_deactivation %>% homologene::mouse2human()
Cortex_ODC = mouseMarkerGenes$Cortex$Oligo %>% homologene::mouse2human()
Cortex_OPC = mouseMarkerGenes$Cortex$OligoPrecursors %>% homologene::mouse2human()
Cortex_Pyramidal = mouseMarkerGenes$Cortex$Pyramidal %>% homologene::mouse2human()

all_genes <- as.character(rownames(Cortex.integrated@data))
#mouseHumanGeneTable_Nigra_oligo_sub <- mouseHumanGeneTable_Nigra_oligo[mouseHumanGeneTable_Nigra_oligo %in% all_genes ]
sample_Cortex.markers_astrocyte <- merge(Cortex_0.8_clustermarkers, Cortex_astrocyte, by.x="gene", by.y="humanGene")

sample_Cortex.markers_endothelial<- merge(Cortex_0.8_clustermarkers, Cortex_endothelial, by.x="gene", by.y="humanGene")
sample_Cortex.markers_GabaPV<- merge(Cortex_0.8_clustermarkers, Cortex_GabaPV, by.x="gene", by.y="humanGene")
sample_Cortex.markers_GabaRelnCalb <- merge(Cortex_0.8_clustermarkers, Cortex_GabaRelnCalb, by.x="gene", by.y="humanGene")
sample_Cortex.markers_GabaVIPReln <- merge(Cortex_0.8_clustermarkers, Cortex_GabaVIPReln, by.x="gene", by.y="humanGene")
sample_Cortex.markers_Microglia <- merge(Cortex_0.8_clustermarkers, Cortex_Microglia, by.x="gene", by.y="humanGene")
sample_Cortex.markers_Microglia_activation <- merge(Cortex_0.8_clustermarkers, Cortex_Microglia_activation, by.x="gene", by.y="humanGene")
sample_Cortex.markers_Cortex_Microglia_deactivation <- merge(Cortex_0.8_clustermarkers, Cortex_Microglia_deactivation, by.x="gene", by.y="humanGene")
sample_Cortex.markers_Cortex_ODC <- merge(Cortex_0.8_clustermarkers, Cortex_ODC, by.x="gene", by.y="humanGene")
sample_Cortex.markers_Cortex_OPC <- merge(Cortex_0.8_clustermarkers, Cortex_OPC, by.x="gene", by.y="humanGene")
sample_Cortex.markers_Cortex_Pyramidal <- merge(Cortex_0.8_clustermarkers, Cortex_Pyramidal, by.x="gene", by.y="humanGene")
```

#astrocyte cluster identification , based on neuroexpresso gene set score (averaging all the genes together for all cells), cluster 7 and a few cells in cluster 18

```{r markerplots, fig.width=15, fig.height=6 }

#Also, I don't know if averaging scaled values might be a better choice here compared to simply averaging #raw or normalised expression values. You can simply exchange object@data[gene.set, ] with #object@scale.data[gene.set, ] when computing colMeans().

# Select genes of interest (using sample() here for demonstration purposes)
#gene.set_astrocyte <- sample_Nigra.markers_astrocyte[ which(sample_Nigra.markers_astrocyte$avg_logFC > 0), ]
gene.set_astrocyte <- unique(Cortex_astrocyte$humanGene)
gene.set <- Reduce(intersect, list(all_genes,gene.set_astrocyte))

Astrocyte_DEG <- Cortex_0.8_clustermarkers%>%
  filter(gene %in% gene.set_astrocyte)
Astrocyte_DEG_sig <- subset(Astrocyte_DEG, Astrocyte_DEG$p_val_adj <= 0.05, select=1:7)

Astrocyte_DEG_sig <- as.character(unique(Astrocyte_DEG_sig$gene))



# Get mean expression of genes of interest per cell
mean.exp <- colMeans(x = Cortex.integrated@scale.data[gene.set, ], na.rm = TRUE)

#mean.exp <- colMeans(x = cluster.averages@scale.data[gene.set, ], na.rm = TRUE)

mean.exp <- colMeans(x = Cortex.integrated@scale.data[gene.set, ], na.rm = TRUE)
# Add mean expression values in 'object@meta.data$gene.set.score'
if (all(names(x = mean.exp) == rownames(x = Cortex.integrated@meta.data))) {
  cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
      "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  Cortex.integrated@meta.data$gene_set_astrocyte_score <- mean.exp
}


#if (all(names(x = mean.exp) == rownames(x = cluster.averages@meta.data))) {
 # cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
  #    "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  #cluster.averages@meta.data$gene_set_astrocyte_score <- mean.exp
#}

# Plot mean expression using Seurat::FeaturePlot() for all astrocyte genes thats are differentially expressed in clusters in the dataset
FeaturePlot(object = Cortex.integrated, features.plot = "gene_set_astrocyte_score",cols.use = c("grey", "red"), reduction.use = "tsne")
VlnPlot(object = Cortex.integrated, features.plot = "gene_set_astrocyte_score", do.sort = T, point.size.use = 0, x.lab.rot = T)
DotPlot(Cortex.integrated, genes.plot = Astrocyte_DEG_sig, cols.use = , plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
```

# astrocyte cluster identification based on established Marker genes and DE marker genes, cluster 7 and cluster 18
```{r,fig.height=20, fig.width=15,}
# astrocyte cluster identification Zhang, 2016 paper
VlnPlot(object = Cortex.integrated, features.plot = c("GFAP","ALDH1L1", "AQP4", "GJA1", "SOX9","CLU","SLC1A3","A2M"), nCol = 2, do.sort = T,do.return = T, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("GFAP","ALDH1L1", "AQP4", "GJA1", "SOX9","CLU","SLC1A3","A2M"), nCol = 2, do.sort = T,do.return = T, group.by="sample", x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("GFAP","ALDH1L1", "AQP4", "GJA1", "SOX9","CLU","SLC1A3","A2M"), nCol = 2, do.sort = T,do.return = T, use.scaled=T, x.lab.rot = T)
# you can plot raw UMI counts as well
#VlnPlot(object = sample_N4_N4B, features.plot = c("GFAP","ALDH1L1", "AQP4", "GJA1", "SOX9","SLC1A3","A2M", "CLU"), use.raw = TRUE, y.log = TRUE, do.sort = T)

#identify clusters based on marker lists from neuroexpresso
#human_cortex_astrocyte <- as.vector(mouseHumanGeneTable_Cortex_astrocyte$humanGene)

# check for astrocyte expression
FeaturePlot(object = Cortex.integrated, features.plot =c ("GFAP","ALDH1L1", "AQP4", "GJA1", "SOX9","CLU","SLC1A3","A2M"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol = 2)

# by merging astorcyte marker list from neuroexpresso wit DEG list for each cluster
VlnPlot(object = Cortex.integrated, features.plot = c("ACSBG1","SLC1A2","AGT", "ETNPPL", "ZNRF3", "HOPX","SLC14A1","GJB6", "AQP4"), nCol = 2, do.sort = T,do.return = T,x.lab.rot = T)

FeaturePlot(object = Cortex.integrated, features.plot =c ("ACSBG1","SLC1A2","AGT", "ETNPPL", "ZNRF3", "HOPX","SLC14A1","GJB6", "AQP4"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol = 2)
```

# Microglia  cluster identification , cluster 6

```{r markerplots, fig.width=15}


gene.set_microglia <- unique(Cortex_Microglia$humanGene)
gene.set <- Reduce(intersect, list(all_genes,gene.set_microglia))

# Get mean expression of genes of interest per cell
mean.exp <- colMeans(x = Cortex.integrated@scale.data[gene.set, ], na.rm = TRUE)

#mean.exp <- colMeans(x = cluster.averages@scale.data[gene.set, ], na.rm = TRUE)

Microglia_DEG <-Cortex_0.8_clustermarkers %>%
  filter(gene %in% gene.set_microglia)
Microglia_DEG_sig <- subset(Microglia_DEG, Microglia_DEG$p_val_adj <= 0.05, select=1:7)

Microglia_DEG_sig <- as.character(unique(Microglia_DEG_sig$gene))

# Add mean expression values in 'object@meta.data$gene.set.score'
if (all(names(x = mean.exp) == rownames(x = Cortex.integrated@meta.data))) {
  cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
      "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  Cortex.integrated@meta.data$gene_set_microglia_score <- mean.exp
}

#if (all(names(x = mean.exp) == rownames(x = cluster.averages@meta.data))) {
 # cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
  #    "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  #cluster.averages@meta.data$gene_set_microglia_score <- mean.exp
#}




# Plot mean expression using Seurat::FeaturePlot() for all astrocyte genes thats are differentially expressed in clusters in the dataset
FeaturePlot(object = Cortex.integrated, features.plot = "gene_set_microglia_score",cols.use = c("grey", "red"), reduction.use = "tsne")
VlnPlot(object = Cortex.integrated, features.plot = "gene_set_microglia_score", do.sort = T, point.size.use = 0.0, x.lab.rot = T)
DotPlot(Cortex.integrated, genes.plot = Microglia_DEG_sig, cols.use = , plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
```
# Microglia Identification cluster 6
```{r,, fig.height=20, fig.width=20}
# MICROLGIA/macrophage markers from Zhang 2016 paper and Galatro_2017 paper
VlnPlot(object = Cortex.integrated, features.plot = c("ADGRG1", "CCL3", "TLR2", "CX3CR1", "IL1A","ITGAM","CSF1R", "P2RY12"), nCol = 2, do.sort = T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("ADGRG1", "CCL3", "TLR2", "CX3CR1", "IL1A","ITGAM","CSF1R", "P2RY12"), nCol = 2, do.sort = T, use.scaled=T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("ADGRG1", "CCL3", "TLR2", "CX3CR1", "IL1A","ITGAM","CSF1R", "P2RY12"), nCol = 2, do.sort = T, use.scaled=T, point.size.use = 0, group.by = "sample")
FeaturePlot(object = Cortex.integrated, features.plot =c ("ADGRG1", "CCL3", "TLR2", "CX3CR1", "IL1A","ITGAM","CSF1R", "P2RY12"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)

# you can plot raw UMI counts as well
#VlnPlot(object = sample_6_n3, features.plot = c("GFAP","ALDH1L1", "AQP4", "GJA1", "SOX9","SLC1A3","A2M"), use.raw = TRUE, y.log = TRUE, do.sort = T)

# Microglia cores genes #cortex # Galatro et al 2017
VlnPlot(object = Cortex.integrated, features.plot = c("FGD2", "ITGAL", "RHBDF2", "CSF3R","ITGAM","VAV1", "P2RY12", "BLNK","TNF","ITGAL"), nCol = 2, do.sort = T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("FGD2", "ITGAL", "RHBDF2", "CSF3R","ITGAM","VAV1", "P2RY12", "BLNK","TNF","ITGAL"), nCol = 2, do.sort = T, use.scaled=T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("FGD2", "ITGAL", "RHBDF2", "CSF3R","ITGAM","VAV1", "P2RY12", "BLNK","TNF","ITGAL"), nCol = 2, do.sort = T, use.scaled=T, point.size.use = 0, group.by = "sample")
FeaturePlot(object = Cortex.integrated, features.plot =c ("FGD2", "ITGAL", "RHBDF2", "CSF3R","ITGAM","VAV1", "P2RY12", "BLNK","TNF","ITGAL"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol = 2)

#identify clusters based on marker lists from  for SN microglia that are differentially expressed between clusters

VlnPlot(object = Cortex.integrated, features.plot = c("CSF3R","SRGAP2", "DOCK8","PLXDC2", "TBXAS1","SLC11A1", "CSF2RA", "SYK" ), nCol = 2, do.sort = T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("CSF3R","SRGAP2", "DOCK8","PLXDC2", "TBXAS1","SLC11A1", "CSF2RA", "SYK" ), nCol = 2, do.sort = T, use.scaled=T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("CSF3R","SRGAP2", "DOCK8","PLXDC2", "TBXAS1","SLC11A1", "CSF2RA", "SYK" ), nCol = 2, do.sort = T, use.scaled=T, point.size.use = 0, group.by = "sample")
FeaturePlot(object = Cortex.integrated, features.plot =c ("CSF3R","SRGAP2", "DOCK8","PLXDC2", "TBXAS1","SLC11A1", "CSF2RA", "SYK" ), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)

```
# Activated  Microglia  cluster identification , cluster 6

```{r markerplots}


gene.set_microglia_activation <- unique(Cortex_Microglia_activation$humanGene)
gene.set <- Reduce(intersect, list(all_genes,gene.set_microglia_activation))

# Get mean expression of genes of interest per cell
#mean.exp <- colMeans(x = Cortex.integrated@scale.data[gene.set, ], na.rm = TRUE)

mean.exp <- colMeans(x = cluster.averages@scale.data[gene.set, ], na.rm = TRUE)
Microglia_activated_DEG <- Cortex_0.8_clustermarkers %>%
  filter(gene %in% gene.set_microglia_activation)
Microglia_activated_DEG_sig <- subset(Microglia_activated_DEG, Microglia_activated_DEG$p_val_adj <= 0.05, select=1:7)

Microglia_activated_DEG_sig <- as.character(unique(Microglia_activated_DEG_sig$gene))


# Add mean expression values in 'object@meta.data$gene.set.score'
if (all(names(x = mean.exp) == rownames(x = Cortex.integrated@meta.data))) {
  cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
      "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  Cortex.integrated@meta.data$gene_set_microglia_activation_score <- mean.exp
}

#if (all(names(x = mean.exp) == rownames(x = cluster.averages@meta.data))) {
 # cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
  #    "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  #cluster.averages@meta.data$gene_set_microglia_activation_score <- mean.exp
 #}


# Plot mean expression using Seurat::FeaturePlot() for all astrocyte genes thats are differentially expressed in clusters in the dataset
FeaturePlot(object = Cortex.integrated, features.plot = "gene_set_microglia_activation_score",cols.use = c("grey", "red"), reduction.use = "tsne")
VlnPlot(object = Cortex.integrated, features.plot = "gene_set_microglia_activation_score", do.sort = T, point.size.use = 0.0, x.lab.rot = T)

# plot dotplots for all sifgnificant DEG expressed microglia genes from neuroexpresso
DotPlot(Cortex.integrated, genes.plot = Microglia_activated_DEG_sig , plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
```
# De-Activated  Microglia  cluster identification , cluster 6

```{r markerplots, fig.width=15}


gene.set_microglia_deactivation <- unique(Cortex_Microglia_deactivation$humanGene)
gene.set <- Reduce(intersect, list(all_genes,gene.set_microglia_deactivation))

Microglia_deactivated_DEG <- Cortex_0.8_clustermarkers %>%
  filter(gene %in% gene.set_microglia_deactivation)
Microglia_deactivated_DEG_sig <- subset(Microglia_deactivated_DEG, Microglia_deactivated_DEG$p_val_adj <= 0.05, select=1:7)

Microglia_deactivated_DEG_sig <- as.character(unique(Microglia_deactivated_DEG_sig$gene))


# Get mean expression of genes of interest per cell
mean.exp <- colMeans(x = Cortex.integrated@scale.data[gene.set, ], na.rm = TRUE)

#mean.exp <- colMeans(x = cluster.averages@scale.data[gene.set, ], na.rm = TRUE)



# Add mean expression values in 'object@meta.data$gene.set.score'
if (all(names(x = mean.exp) == rownames(x = Cortex.integrated@meta.data))) {
  cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
      "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  Cortex.integrated@meta.data$gene_set_microglia_deactivation_score <- mean.exp
}

#if (all(names(x = mean.exp) == rownames(x = cluster.averages@meta.data))) {
   #cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
      #"adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  #cluster.averages@meta.data$gene_set_microglia_deactivation_score <- mean.exp
#}




# Plot mean expression using Seurat::FeaturePlot() for all astrocyte genes thats are differentially expressed in clusters in the dataset
FeaturePlot(object = Cortex.integrated, features.plot = "gene_set_microglia_deactivation_score",cols.use = c("grey", "red"), reduction.use = "tsne")
VlnPlot(object = Cortex.integrated, features.plot = "gene_set_microglia_deactivation_score", do.sort = T, point.size.use = 0.0, x.lab.rot = T)

# plot dotplots for all sifgnificant DEG expressed microglia genes from neuroexpresso
DotPlot(Cortex.integrated, genes.plot = Microglia_deactivated_DEG_sig , plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
```
# oligo cluster identification in cortex , cluster 18

```{r markerplots, fig.height=6, fig.width=15,}

# Select genes of interest (using sample() here for demonstration purposes)
#gene.set_oligo <- sample_Nigra.markers_oligo[ which(sample_Nigra.markers_oligo$avg_logFC > 0), ]
gene.set_odc <- unique(Cortex_ODC$humanGene)
gene.set <- Reduce(intersect, list(all_genes,gene.set_odc))

# Get mean expression of genes of interest per cell
mean.exp <- colMeans(x = Cortex.integrated@scale.data[gene.set, ], na.rm = TRUE)

#mean.exp <- colMeans(x = cluster.averages@scale.data[gene.set, ], na.rm = TRUE)


#mean.exp <- colMeans(x = cluster.averages@scale.data[gene.set, ], na.rm = TRUE)
Oligo_DEG <- Cortex_0.8_clustermarkers %>%
  filter(gene %in% gene.set_odc)
Oligo_DEG_sig <- subset(Oligo_DEG, Oligo_DEG$p_val_adj <= 0.05, select=1:7)

Oligo_DEG_sig <- as.character(unique(Oligo_DEG_sig$gene))

# Add mean expression values in 'object@meta.data$gene.set.score'
if (all(names(x = mean.exp) == rownames(x = Cortex.integrated@meta.data))) {
  cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
      "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  Cortex.integrated@meta.data$gene_set_odc_score <- mean.exp
}

#if (all(names(x = mean.exp) == rownames(x = cluster.averages@meta.data))) {
  #cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
      #"adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  #cluster.averages@meta.data$gene_set_odc_score <- mean.exp
#}
# Plot mean expression using Seurat::FeaturePlot() for all astrocyte genes thats are differentially expressed in clusters in the dataset
FeaturePlot(object = Cortex.integrated, features.plot = "gene_set_odc_score",cols.use = c("grey", "red"), reduction.use = "tsne")
VlnPlot(object = Cortex.integrated, features.plot = "gene_set_odc_score", do.sort = T, point.size.use = 0.0,x.lab.rot = T)

# plot dotplots for all sifgnificant DEG expressed oligo genes from neuroexpresso
DotPlot(Cortex.integrated, genes.plot = Oligo_DEG_sig , plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
```

# oligo cluster identification in cortex , cluster 18
```{r markerplots, fig.height=20, fig.width=15,}

# OLIGOdendrocytes markers from Zhang 2016 paper

VlnPlot(object = Cortex.integrated, features.plot = c("MOG", "MOBP", "SOX10", "PLP1", "GPR37"), use.scaled=TRUE, do.sort = T, same.y.lims = T, nCol=2, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("MOG", "MOBP", "SOX10", "PLP1", "GPR37"), do.sort = T, same.y.lims = T, nCol=2, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("MOG", "MOBP", "SOX10", "PLP1", "GPR37"), do.sort = T, same.y.lims = T, nCol=2, group.by = "sample", use.scaled=T, point.size.use = 0)
FeaturePlot(object = Cortex.integrated, features.plot =c ("MOG", "MOBP", "SOX10", "PLP1", "GPR37"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)

# neruoexpresso Cortex oligo DE list
VlnPlot(object = Cortex.integrated, features.plot = c("ST18","MBP","MOBP","PPP1R14A","SLC44A1","CLDN11","MAG","CTNNA3","PLEKHH1","MOG"), nCol = 2,  use.scaled=TRUE, do.sort = T, same.y.lims = T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("ST18","MBP","MOBP","PPP1R14A","SLC44A1","CLDN11","MAG","CTNNA3","PLEKHH1","MOG" ), nCol = 2,  use.scaled=TRUE, do.sort = T, same.y.lims = T, point.size.use = 0, group.by = "sample")
VlnPlot(object = Cortex.integrated, features.plot = c("ST18","MBP","MOBP","PPP1R14A","SLC44A1","CLDN11","MAG","CTNNA3","PLEKHH1","MOG"), nCol = 2, do.sort = T, same.y.lims = T, point.size.use = 0)
FeaturePlot(object = Cortex.integrated, features.plot =c ("ST18","MBP","MOBP","PPP1R14A","SLC44A1","CLDN11","MAG","CTNNA3","PLEKHH1","MOG"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol = 2)



```
# Endothelial cluster identification, based on neuroexpresso geneset score, None

```{r markerplots, fig.height=5, fig.width=10}

# Select genes of interest (using sample() here for demonstration purposes)
#gene.set_oligo <- sample_Nigra.markers_oligo[ which(sample_Nigra.markers_oligo$avg_logFC > 0), ]
gene.set_endothelial <- unique(Cortex_endothelial$humanGene)
gene.set <- Reduce(intersect, list(all_genes,gene.set_endothelial))

Endothelial_DEG <- Cortex_0.8_clustermarkers %>%
  filter(gene %in% gene.set_endothelial)
Endothelial_DEG_sig <- subset(Endothelial_DEG, Endothelial_DEG$p_val_adj <= 0.05, select=1:7)

Endothelial_DEG_sig <- as.character(unique(Endothelial_DEG_sig$gene))



# Get mean expression of genes of interest per cell
mean.exp <- colMeans(x = Cortex.integrated@data[gene.set, ], na.rm = TRUE)

#mean.exp <- colMeans(x = cluster.averages@data[gene.set, ], na.rm = TRUE)


# Add mean expression values in 'object@meta.data$gene.set.score'
if (all(names(x = mean.exp) == rownames(x = Cortex.integrated@meta.data))) {
  cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
      "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  Cortex.integrated@meta.data$gene_set_endothelial_score <- mean.exp
}

#if (all(names(x = mean.exp) == rownames(x = cluster.averages@meta.data))) {
  #cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
      #"adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  #cluster.averages@meta.data$gene_set_endothelial_score <- mean.exp
 #}

# Plot mean expression using Seurat::FeaturePlot() for all astrocyte genes thats are differentially expressed in clusters in the dataset
FeaturePlot(object = Cortex.integrated, features.plot = "gene_set_endothelial_score",cols.use = c("grey", "red"), reduction.use = "tsne")
VlnPlot(object = Cortex.integrated, features.plot = "gene_set_endothelial_score", do.sort = T, point.size.use = 0.0, x.lab.rot = T)

# plot dotplots for all sifgnificant DEG expressed endothelial genes from neuroexpresso
DotPlot(Cortex.integrated, genes.plot = Endothelial_DEG_sig , plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)

```




# Endothelial cluster identification, very few endothelials, cluster 24, I think. Not at all clear

```{r markerplots, fig.height=12, fig.width=15,}
# endothelial markers from Zhang 2016 paper
VlnPlot(object = Cortex.integrated, features.plot = c("CLDN5","ESAM", "ICAM2","APOLD1","FLT1","RGS5","EMCN","SDPR","IFI27","MT2A"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("CLDN5","ESAM", "ICAM2","APOLD1","FLT1","RGS5","EMCN","IFI27","MT2A"), nCol = 2,  use.raw = TRUE, do.sort = T, y.log = TRUE, point.size.use = 0)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CLDN5","ESAM", "ICAM2","APOLD1", "FLT1","RGS5","EMCN","IFI27", "MT2A"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)

# by merging astorcyte marker list from neuroexpresso wit DEG list for each cluster
FeaturePlot(object = Cortex.integrated, features.plot =c ("ATP10A","ABCB1", "ANXA4","FZD6", "RGS5","PDGFRB","ARHGAP29","RHOJ", "SOX13"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
VlnPlot(object = Cortex.integrated, features.plot = c("ATP10A","ABCB1", "ANXA4","FZD6", "RGS5","PDGFRB","ARHGAP29","RHOJ", "SOX13"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0)

# Endothelial markers lake paper
FeaturePlot(object = Cortex.integrated, features.plot =c ("RBFOX3","IGFBP7","B2M"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
VlnPlot(object = Cortex.integrated, features.plot = c("RBFOX3","IGFBP7","B2M"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0)
```
# cortex GabaPV or Gabanergic interneurons cluster identification

```{r markerplots, fig.height=7, fig.width=8}

# Select genes of interest (using sample() here for demonstration purposes)
#gene.set_oligo <- sample_Nigra.markers_oligo[ which(sample_Nigra.markers_oligo$avg_logFC > 0), ]
gene.set_gaba_pv <- unique(Cortex_GabaPV$humanGene)
gene.set_gaba_pv <- c(gene.set_gaba_pv ,"GAD1","GAD2","SLC32A1","SLC6A1")
gene.set <- Reduce(intersect, list(all_genes,gene.set_gaba_pv))

Gaba_DEG <- Cortex_0.8_clustermarkers %>%
  filter(gene %in% gene.set_gaba_pv)
Gaba_DEG_sig <- subset(Gaba_DEG, Gaba_DEG$p_val_adj <= 0.05, select=1:7)

Gaba_DEG_sig <- as.character(unique(Gaba_DEG_sig$gene))



# Get mean expression of genes of interest per cell
mean.exp <- colMeans(x = Cortex.integrated@data[gene.set, ], na.rm = TRUE)

#mean.exp <- colMeans(x = cluster.averages@data[gene.set, ], na.rm = TRUE)



# Add mean expression values in 'object@meta.data$gene.set.score'
if (all(names(x = mean.exp) == rownames(x = Cortex.integrated@meta.data))) {
  cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
      "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  Cortex.integrated@meta.data$gene_set_gaba_pv_score <- mean.exp
}

#if (all(names(x = mean.exp) == rownames(x = cluster.averages@meta.data))) {
 # cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
     #"adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  #cluster.averages@meta.data$gene_set_gaba_pv_score <- mean.exp
#}


# Plot mean expression using Seurat::FeaturePlot() for all astrocyte genes thats are differentially expressed in clusters in the dataset
FeaturePlot(object = Cortex.integrated, features.plot = "gene_set_gaba_pv_score",cols.use = c("grey", "red"), reduction.use = "tsne")
VlnPlot(object = Cortex.integrated, features.plot = "gene_set_gaba_pv_score", do.sort = T, point.size.use = 0.0,x.lab.rot = T, use.scaled=T)

# plot dotplots for all sifgnificant DEG expressed endothelial genes from neuroexpresso
DotPlot(Cortex.integrated, genes.plot = Gaba_DEG_sig , plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
```
# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV, cluster 15,3,19,22,16,21,12,8,9,6
```{r markerplots, fig.height=8, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("GAD1","ERBB4","PVALB","GAD2","SLC32A1","SLC6A1"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("GAD1","ERBB4","PVALB","GAD2","SLC32A1","SLC6A1"), nCol = 2,  use.raw = TRUE, do.sort = T, y.log = TRUE, point.size.use = 0)
FeaturePlot(object = Cortex.integrated, features.plot =c ("GAD1","ERBB4","PVALB","GAD2","SLC32A1","SLC6A1"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)

```
# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV, subtype in1a (Lake_2017 paper)- Cluster 21 (CCK,CNR1, RELN)

```{r markerplots, fig.height=12, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CCK","CNR1","RELN","CXCL14","ADARB2","CRH","NDNF","VIP"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CCK","CNR1","RELN","CXCL14","ADARB2","CRH","NDNF","VIP"), nCol = 2, do.sort = T, y.log = TRUE, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CCK","CNR1","RELN","CXCL14","ADARB2","CRH","NDNF","VIP"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CCK","CNR1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("RELN","NDNF"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("RELN","VIP"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```
# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV, subtype in1b (Lake_2017 paper)- CLUSTER 9 

```{r markerplots, fig.height=8, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CCK","CNR1","PRELID2","C8orf34","THSD7B"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("CCK","CNR1","THSD7B","PRELID2","C8orf34"), nCol = 2, do.sort = T, point.size.use = 0)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CCK","CNR1","THSD7B","PRELID2","C8orf34"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CCK","THSD7B"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("THSD7B","CNR1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("THSD7B","C8orf34"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```
# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV, subtype in1c (Lake_2017 paper)- CLUSTER 4

```{r markerplots, fig.height=12, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CCK","CNR1","VIP","TAC3","CALB2"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0,x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CCK","CNR1","VIP","TAC3","CALB2"), nCol = 2, do.sort = T, point.size.use = 0,x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CCK","CNR1","VIP","TAC3","CALB2"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CCK","VIP"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CCK","TAC3"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("VIP","TAC3"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```
# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV, subtype in2 (Lake_2017 paper)- Look at other markers for the cluster? - most probably not present in my cell types. As no clear expression in one cluster is seen. more like a few cells here and there

```{r markerplots, fig.height=20, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CCK","CNR1","RELN","VIP","CALB2","GALNTL6","INPP4B","TTN","ALCAM","KCNT2"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CCK","CNR1","RELN","VIP","CALB2","GALNTL6","INPP4B","ALCAM","KCNT2","TTN"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CCK","CNR1","RELN","VIP","CALB2","GALNTL6","INPP4B","ALCAM","KCNT2"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
```
# IN2 subtype (lake 2017 paper)
```{r, fig.height=5, fig.width=8}
FeaturePlot(object = Cortex.integrated, features.plot =c ("CALB2","VIP"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CALB2","GALNTL6"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CNR1","CALB2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("ALCAM","KCNT2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```
# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV, subtype In3 (Lake_2017 paper)- THSD7A, RYR3,TSHZ2
```{r markerplots, fig.height=12, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("GAD1","TSHZ2","RYR3","THSD7A","VIP","RELN","KMO"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0,x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("GAD1","TSHZ2","RYR3","THSD7A","VIP","RELN","KMO"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("GAD1","TSHZ2","RYR3","VIP","RELN","THSD7A","KMO"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("RYR3","TSHZ2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("THSD7A","TSHZ2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```
# subtype In3 base don lake paper based on markers RYR3 and TSZH2 and PDE9A
```{r}
select.cells <- TSNEPlot(object = Cortex.integrated, do.identify = TRUE)
Cortex.integrated <- SetIdent(object = Cortex.integrated, cells.use = select.cells, ident.use = "In3")

# markers specific to In3 Subtype compared to every other cluster
In3_markers <- FindMarkers(object = Cortex.integrated, ident.1 = "In3", min.pct = 0.25, thresh.use = 0.25, test.use="negbinom", logfc.threshold = 0.25 
   ,only.pos = TRUE, min.diff.pct = 0.3)
```





# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV, subtype In4a (Lake_2017 paper)- part of cluster 1b
```{r markerplots, fig.height=12, fig.width=15,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CNR1","RELN","VIP","COL5A2","SV2C","FRAS1","HS3ST5","NDNF"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CNR1","RELN","VIP", "COL5A2","SV2C","HS3ST5","NDNF"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CNR1","RELN","COL5A2", "VIP","SV2C","HS3ST5","NDNF"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("COL5A2","SV2C"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("COL5A2","HS3ST5"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("COL5A2","RELN"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```
# subset of in1b might be in4a , so select those cells out and see if differential expression shows anything, COL5A2, SV2C,RELN,HS3ST5
```{r}
select.cells <- TSNEPlot(object = Cortex.integrated, do.identify = TRUE)
Cortex.integrated <- SetIdent(object = Cortex.integrated, cells.use = select.cells, ident.use = "In4A")

# markers specific to In3 Subtype compared to every other cluster
In4A_markers <- FindMarkers(object = Cortex.integrated, ident.1 = "In4A", min.pct = 0.25, thresh.use = 0.25, test.use="negbinom", logfc.threshold = 0.25 
   ,only.pos = TRUE, min.diff.pct = 0.3)
```




# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV, subtype In4B (Lake_2017 paper)- CLUSTER 22 AND SECOND CLUSTER 12
```{r markerplots, fig.height=12, fig.width=15,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CCK","SV2C","EYA4","LAMP5","PTCHD4","HPCAL1","NTNG1"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CCK","SV2C","EYA4","LAMP5","PTCHD4","HPCAL1","NTNG1"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CCK","SV2C","EYA4","LAMP5","PTCHD4","HPCAL1","NTNG1"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("SV2C","EYA4"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```
# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV, subtype In5 (Lake_2016 paper)- SV2C, SULF1, NOS1, CCK, TAC1,CALB1,
```{r, fig.height=12, fig.width=15}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CCK","TNFAIP8L3","CALB1","NOS1","TAC1","SULF1","SV2C"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CCK","TNFAIP8L3","CALB1","NOS1","TAC1","SULF1","SV2C"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CCK","TNFAIP8L3","CALB1","NOS1","TAC1","SULF1","SV2C"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CCK","TNFAIP8L3"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("NOS1","TAC1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("NOS1","CALB1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("NOS1","SULF1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```
# The outlier cluster In4b is actually In5 from Lake_2016 paper , so select those cells out and see if differential expression shows anything,SV2C, SULF1, NOS1, CCK, TAC1,CALB1
```{r}
select.cells <- TSNEPlot(object = Cortex.integrated, do.identify = TRUE)
Cortex.integrated <- SetIdent(object = Cortex.integrated, cells.use = select.cells, ident.use = "In5")

# markers specific to In3 Subtype compared to every other cluster
In5_markers <- FindMarkers(object = Cortex.integrated, ident.1 = "In5", min.pct = 0.25, thresh.use = 0.25, test.use="negbinom", logfc.threshold = 0.25 
   ,only.pos = TRUE, min.diff.pct = 0.3)
```




# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV, subtype In6A (Lake_2017 paper)- CLUSTER 19
```{r markerplots, fig.height=10, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CA8","PVALB","RYR1"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CA8","PVALB","RYR1"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CA8","PVALB","RYR1"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("PVALB","RYR1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("PVALB","CA8"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("RYR1","CA8"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```
# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV, subtype In6b (Lake_2017 paper)- CLUSTER 15 AND MAYBE CLUSTER 3
```{r markerplots, fig.height=10, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("PVALB","TAC1","TMEM132C","SLC9A9","CEMIP","CRHBP"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("PVALB","TAC1","TMEM132C","SLC9A9","CRHBP"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("PVALB","TAC1","TMEM132C","SLC9A9","CRHBP","CEMIP"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("PVALB","TAC1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CEMIP","CRHBP"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("PVALB","CRHBP"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```
# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV, subtype In7 (Lake_2017 paper)- NO CLUSTER
```{r markerplots, fig.height=8, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CALB1","NPY","SST"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CALB1","NPY","SST"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CALB1","NPY","SST"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CALB1","SST"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("NPY","SST"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```
# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV OR INTERNEURONS, subtype In8 (Lake_2017 paper)- cluster 8
```{r markerplots, fig.height=12, fig.width=15,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("GAD1", "SST","STXBP6","PCDH15","TAC1","NOS1","CALB1"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("GAD1", "SST","STXBP6","PCDH15","TAC1","NOS1","CALB1"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("GAD1", "SST","STXBP6","PCDH15","TAC1","NOS1","CALB1"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("SST","STXBP6"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("SST","NOS1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```



# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV OR INTERNEURONS, subtype Purk1 (Lake_2017 paper)- AMBIGUOUS, NOT SPECIFIC CLUSTER FOR THIS CELL TYPE
```{r markerplots, fig.height=6, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("RELN","LMCD1","RYR1"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("RELN","LMCD1","RYR1"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("RELN","LMCD1","RYR1"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("LMCD1","RYR1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```
# Gaba PV or Gabanergic internuerons marker identification, DEG neurexpresso markers for GabaPV OR INTERNEURONS, subtype Purk2 (Lake_2017 paper)-NOT CLEAR 
```{r markerplots, fig.height=12, fig.width=15}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("GAD1","RYR1","CNR1","RELN","PVALB","GLCE"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("GAD1","RYR1","CNR1","RELN","PVALB","GLCE"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("GAD1","RYR1","CNR1","RELN","PVALB","GLCE"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("GLCE","RYR1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```

# Cortex_Pyramidal cluster identification
```{r markerplots, fig.height=8, fig.width=12,}

# Select genes of interest (using sample() here for demonstration purposes)
#gene.set_oligo <- sample_Nigra.markers_oligo[ which(sample_Nigra.markers_oligo$avg_logFC > 0), ]
gene.set_Pyramidal <- unique(Cortex_Pyramidal$humanGene)
gene.set <- Reduce(intersect, list(all_genes,gene.set_Pyramidal))

pyramidal_DEG <- Cortex_0.8_clustermarkers %>%
  filter(gene %in% gene.set_Pyramidal)
pyramidal_DEG_sig <- subset(pyramidal_DEG, pyramidal_DEG$p_val_adj <= 0.05, select=1:7)

pyramidal_DEG_sig <- as.character(unique(pyramidal_DEG_sig$gene))

# Get mean expression of genes of interest per cell
mean.exp <- colMeans(x = Cortex.integrated@data[gene.set, ], na.rm = TRUE)

#mean.exp <- colMeans(x = cluster.averages@data[gene.set, ], na.rm = TRUE)

# Add mean expression values in 'object@meta.data$gene.set.score'
if (all(names(x = mean.exp) == rownames(x = Cortex.integrated@meta.data))) {
  cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
      "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  Cortex.integrated@meta.data$gene_set_Pyramidal_score <- mean.exp
}

#if (all(names(x = mean.exp) == rownames(x = cluster.averages@meta.data))) {
 # cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
     # "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
 # cluster.averages@meta.data$gene_set_Pyramidal_score <- mean.exp
#}

# Plot mean expression using Seurat::FeaturePlot() for all astrocyte genes thats are differentially expressed in clusters in the dataset
FeaturePlot(object = Cortex.integrated, features.plot = "gene_set_Pyramidal_score",cols.use = c("grey", "red"), reduction.use = "tsne")
VlnPlot(object = Cortex.integrated, features.plot = "gene_set_Pyramidal_score", do.sort = T, point.size.use = 0.0, x.lab.rot = T)

# plot dotplots for all sifgnificant DEG expressed Pyramidal neuron genes genes from neuroexpresso
DotPlot(Cortex.integrated, genes.plot = pyramidal_DEG_sig , plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
```
# Cortex Pyramidal CA1 marker identification, DEG neurexpresso markers OR excitatory neurons
```{r markerplots, fig.height=12, fig.width=15,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("NEUROD6","SATB2","NRN1","GLT8D2","BAIAP2","STX1A","PTK2B","SLC17A7"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("NEUROD6","SATB2","NRN1","GLT8D2","BAIAP2","STX1A","PTK2B","SLC17A7"), nCol = 2,  use.raw = TRUE, do.sort = T, y.log = TRUE, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("NEUROD6","SATB2","NRN1","GLT8D2","BAIAP2","STX1A","PTK2B","SLC17A7"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)

```
#  Excitatory or Pyramidal neuronal subtype identification, subtype Ex1 (Lake_2017 paper)-CLUSTER 1, NEURDO6, SATB2, CUX2,LAMP5
```{r markerplots, fig.height=20, fig.width=15,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CBLN2","RASGRF2","CUX2","PDZD2","ENC1","SYN3","TESPA1","LAMP5","GLRA3"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CBLN2","RASGRF2","CUX2","PDZD2","ENC1","SYN3","TESPA1","LAMP5","GLRA3"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CBLN2","RASGRF2","CUX2","PDZD2","ENC1","SYN3","TESPA1","LAMP5","GLRA3"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
```

```{r markerplots, fig.height=6, fig.width=9}
FeaturePlot(object = Cortex.integrated, features.plot =c ("RASGRF2","CUX2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("SYN3","TESPA1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CUX2","LAMP5"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```

#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex2 (Lake_2017 paper)-CLUSTER 0, CUX2,COL5A2,NEFM, LAMA2
```{r markerplots, fig.height=20, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CBLN2","RASGRF2","COL5A2","CUX2","NEFM","RORB","CARTPT","LAMA2"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CBLN2","RASGRF2","COL5A2","CUX2","NEFM","RORB","CARTPT","LAMA2"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CBLN2","RASGRF2","COL5A2","CUX2","NEFM","RORB","CARTPT","LAMA2"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)

```

```{r markerplots, fig.height=6, fig.width=9}
FeaturePlot(object = Cortex.integrated, features.plot =c ("NEFM","COL5A2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("LAMA2","COL5A2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```
#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex3 (Lake_2017 paper)-PTPRD,TENM2, cluster pyramidal neurons
```{r markerplots, fig.height=20, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CBLN2","RASGRF2","COL5A2","GLIS3","CUX2","NEFM","RORB","PTPRD","TENM2"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CBLN2","RASGRF2","COL5A2","GLIS3","CUX2","NEFM","RORB","PTPRD","TENM2"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CBLN2","RASGRF2","COL5A2","GLIS3","CUX2","NEFM","RORB","PTPRD","TENM2"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)

```

```{r markerplots}
FeaturePlot(object = Cortex.integrated, features.plot =c ("GLIS3","PTPRD"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("TENM2","PTPRD"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("RORB","CUX2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("RORB","PTPRD"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
#Cortex.integrated <- RenameIdent(object = Cortex.integrated, old.ident.name = "Pyramidal_Neurons", new.ident.name = "Ex3")
```

#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex3B (Lake_2017 paper)- NOT SURE
```{r markerplots, fig.height=10, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CUX2","NEFM","RORB","PCP4"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CUX2","NEFM","RORB","PCP4"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CUX2","NEFM","RORB","PCP4"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("RORB","PCP4"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
#FeaturePlot(object = Cortex.integrated, features.plot =c ("CUX2","NEFM","RORB","PCP4"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```

#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex3C (Lake_2017 paper)- NOT SURE
```{r markerplots, fig.height=8, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("NEFM","RORB","NEFL"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("NEFM","RORB"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("NEFM","RORB","NEFL"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("NEFM","NEFL"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
#FeaturePlot(object = Cortex.integrated, features.plot =c ("CUX2","NEFM","RORB","PCP4"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```
#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex3D (Lake_2017 paper)- NOT SURE
```{r markerplots, fig.height=10, fig.width=13,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CUX2","NEFM","RORB","PHACTR2","EYA4","IL1RAPL2","FOXP2"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CUX2","NEFM","RORB","PHACTR2","EYA4","IL1RAPL2","FOXP2"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CUX2","NEFM","RORB","PHACTR2","EYA4","IL1RAPL2","FOXP2"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("PHACTR2","EYA4"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
#FeaturePlot(object = Cortex.integrated, features.plot =c ("CUX2","NEFM","RORB","PCP4"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```
#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex3E (Lake_2017 paper)- NOT SURE
```{r markerplots, fig.height=8, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CBLN2","NEFM","RORB","TMSB4X"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CBLN2","NEFM","RORB","TMSB4X"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CBLN2","NEFM","RORB","TMSB4X"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
#FeaturePlot(object = Cortex.integrated, features.plot =c ("PHACTR2","EYA4"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
#FeaturePlot(object = Cortex.integrated, features.plot =c ("CUX2","NEFM","RORB","PCP4"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```

#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex4 (Lake_2017 paper), CLUSTER 5 AND SECOND IS 17 AND THIRD 14
```{r markerplots, fig.height=10, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("RORB","IL1RAPL2","TSHZ2","FOXP2","DCC","TOX","SLC22A10","TPBG"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("RORB","IL1RAPL2","TSHZ2","FOXP2","DCC","TOX","SLC22A10","TPBG"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("RORB","IL1RAPL2","TSHZ2","FOXP2","DCC","TOX","SLC22A10","TPBG"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("TSHZ2","FOXP2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("IL1RAPL2","FOXP2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("TOX","SLC22A10"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("DCC","SLC22A10"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("RORB","TOX"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```

#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex5A (Lake_2017 paper), CLUSTER2, PCP4, TMSB10
```{r markerplots, fig.height=10, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("NEFM","RORB","IL1RAPL2","FOXP2","PCP4","PDE1C","TMSB10","HS3ST2"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("NEFM","RORB","IL1RAPL2","FOXP2","PCP4","PDE1C","TMSB10","HS3ST2"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("NEFM","RORB","IL1RAPL2","FOXP2","PCP4","PDE1C","TMSB10","HS3ST2"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("PCP4","PDE1C"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("PCP4","TMSB10"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```


#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex5B (Lake_2017 paper), cluster 11
```{r markerplots, fig.height=20, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CBLN2","NEFM","RORB","IL1RAPL2","FOXP2","HS3ST5","PEX5L","PDZRN4","RXFP1","HS3ST2"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CBLN2","NEFM","RORB","IL1RAPL2","FOXP2","HS3ST5","PEX5L","PDZRN4","RXFP1","HS3ST2"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CBLN2","NEFM","RORB","IL1RAPL2","FOXP2","HS3ST5","PEX5L","PDZRN4","RXFP1","HS3ST2"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
```

```{r, markerplots}
FeaturePlot(object = Cortex.integrated, features.plot =c ("RXFP1","HS3ST5"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("HS3ST2","PDZRN4"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("HS3ST5","HS3ST2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```
#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex6A (Lake_2017 paper), CLUSTER 20, HTR2C
```{r markerplots, fig.height=10, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("TSHZ2","FOXP2","PCP4","HTR2C","TLE4"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("TSHZ2","FOXP2","PCP4","HTR2C","TLE4"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("TSHZ2","FOXP2","PCP4","HTR2C","TLE4"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("HTR2C","TLE4"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("HTR2C","PCP4"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```
#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex6B (Lake_2017 paper), CLUSTER 13, TLE4,HS3ST4,DLC1,SEMA3E
```{r markerplots, fig.height=8, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("FOXP2","TLE4","HS3ST4","SEMA3D","DLC1"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("FOXP2","TLE4","HS3ST4","SEMA3D","DLC1"), nCol = 2, do.sort = T, point.size.use = 0,x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("FOXP2","TLE4","HS3ST4","SEMA3D","DLC1"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("HS3ST4","TLE4"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("TLE4","DLC1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("SEMA3D","DLC1"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```
#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex7 (Lake_2017 paper)
```{r markerplots, fig.height=10, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("GRIK3","PDGFC","SLIT3","GRIK4","ST6GALNAC5","TMEM108","ETV1"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("GRIK3","PDGFC","SLIT3","GRIK4","ST6GALNAC5","TMEM108","ETV1"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("GRIK3","PDGFC","SLIT3","GRIK4","ST6GALNAC5","TMEM108","ETV1"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("GRIK3","PDGFC"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("GRIK3","SLIT3"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```


#  Excitatory or Pyrimidal neuronal subtype identification, subtype Ex8 (Lake_2017 paper), CLUSTER 23, NR4A2, POSTN, ZNF804B, MCTP2
```{r markerplots, fig.height=10, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("CBLN2","NR4A2","MCTP2","POSTN","ZNF804B","OPRK1","NTNG2"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("CBLN2","NR4A2","MCTP2","POSTN","ZNF804B","OPRK1","NTNG2"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("CBLN2","NR4A2","MCTP2","POSTN","ZNF804B","OPRK1","NTNG2"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("NR4A2","POSTN"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("POSTN","MCTP2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
FeaturePlot(object = Cortex.integrated, features.plot =c ("ZNF804B","NTNG2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
```
#  Excitatory or Pyrimidal neuronal subtype identification, subtype GRAN (Lake_2017 paper), NOT SURE 12, UNC13C
```{r markerplots, fig.height=10, fig.width=12,}
# Gaba PV
VlnPlot(object = Cortex.integrated, features.plot = c("ZNF385D","RELN","UNC13C"), nCol = 2,  use.scaled=TRUE, do.sort = T, point.size.use = 0, x.lab.rot = T)
VlnPlot(object = Cortex.integrated, features.plot = c("ZNF385D","RELN","UNC13C"), nCol = 2, do.sort = T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("ZNF385D","RELN","UNC13C"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("RELN","UNC13C"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)
#FeaturePlot(object = Cortex.integrated, features.plot =c (), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)

```


# OPC geneset score , cluster 16
```{r markerplots, fig.height=6, fig.width=10,}

# Select genes of interest (using sample() here for demonstration purposes)
#gene.set_oligo <- sample_Nigra.markers_oligo[ which(sample_Nigra.markers_oligo$avg_logFC > 0), ]
gene.set_opc <- unique(Cortex_OPC$humanGene)
gene.set <- Reduce(intersect, list(all_genes,gene.set_opc))

OPC_DEG <- Cortex_0.8_clustermarkers %>%
  filter(gene %in% gene.set_opc)
OPC_DEG_sig <- subset(OPC_DEG, OPC_DEG$p_val_adj <= 0.05, select=1:7)

OPC_DEG_sig <- as.character(unique(OPC_DEG_sig$gene))

# Get mean expression of genes of interest per cell
mean.exp <- colMeans(x = Cortex.integrated@scale.data[gene.set, ], na.rm = TRUE)

mean.exp <- colMeans(x = cluster.averages@scale.data[gene.set, ], na.rm = TRUE)

# Add mean expression values in 'object@meta.data$gene.set.score'
if (all(names(x = mean.exp) == rownames(x = Cortex.integrated@meta.data))) {
  cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
      "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  Cortex.integrated@meta.data$gene_set_opc_score <- mean.exp
}

#if (all(names(x = mean.exp) == rownames(x = cluster.averages@meta.data))) {
 # cat("Cell names order match in 'mean.exp' and 'object@meta.data':\n", 
  #    "adding gene set mean expression values in 'object@meta.data$gene.set.score'")
  #cluster.averages@meta.data$gene_set_opc_score <- mean.exp
#}

# Plot mean expression using Seurat::FeaturePlot() for all astrocyte genes thats are differentially expressed in clusters in the dataset
FeaturePlot(object = Cortex.integrated, features.plot = "gene_set_opc_score",cols.use = c("grey", "red"), reduction.use = "tsne")
VlnPlot(object = Cortex.integrated, features.plot = "gene_set_opc_score", do.sort = T, point.size.use = 0.0, x.lab.rot = T)

# plot dotplots for all sifgnificant DEG expressed Pyramidal neuron genes genes from neuroexpresso
DotPlot(Cortex.integrated, genes.plot = OPC_DEG_sig , plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
```




#OPC identifiication, CLUSTER 16, marker:VCAN, LHFPL3
# markers from Bin Zhang 2018 paper on cell type identitites
```{r markerplots, fig.height=12, fig.width=15,}


# OPC markers from Bin Zhang paper AND deg FROM NEUROEXPRESSO IN CLUSTER 16
VlnPlot(object = Cortex.integrated, features.plot = c("PDGFRA","TNR","PCDH15","VCAN","PHLDA1", "OLIG1","LHFPL3","EPN2"), nCol = 3, do.sort = T,point.size.use = 0, x.lab.rot = T)
#VlnPlot(object = sample_N4_N4B, features.plot = c(), nCol = 4, do.sort = T, use.raw=TRUE, y.log = T)
VlnPlot(object = Cortex.integrated, features.plot = c("PDGFRA","TNR","PCDH15","VCAN","PHLDA1", "OLIG1","LHFPL3","EPN2"), nCol = 3, do.sort = T, use.scaled=T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("PDGFRA","TNR","PCDH15","VCAN","PHLDA1", "OLIG1","LHFPL3","EPN2"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol = 3)



```
# PERICYTES  cell type identification (Lake_2017 paper),  MARKER PDGFRB, ATP1A2, BUT NO SPECIFC CLUSTER

```{r markerplots, fig.height=12, fig.width=15,}


# Peric cell type  markers from LAke 2017 paper
VlnPlot(object = Cortex.integrated, features.plot = c("PDGFRB","COBLL1","ATP1A2","DLC1"), nCol = 2, do.sort = T,point.size.use = 0,x.lab.rot = T)
#VlnPlot(object = sample_N4_N4B, features.plot = c(), nCol = 4, do.sort = T, use.raw=TRUE, y.log = T)
VlnPlot(object = Cortex.integrated, features.plot = c("PDGFRB","COBLL1","ATP1A2","DLC1"), nCol = 2, do.sort = T, use.scaled=T, point.size.use = 0,x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("PDGFRB","COBLL1","ATP1A2","DLC1"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol = 2)
FeaturePlot(object = Cortex.integrated, features.plot =c ("PDGFRB","ATP1A2"), cols.use = c("grey", "red","blue","green"), reduction.use = "tsne", overlay = T, no.legend = F)


```


# Hypothalamic Dopamine;Dat;Nmur2;GABA Neuron
```{r markerplots, fig.height=12, fig.width=15,}
#Human_Nigra_dopaminergic <- as.character(rownames(cluster6.markers))
#Human_Nigra_dopaminergic_final<- Reduce(intersect, list(gene.set_dopinamergic,Human_Nigra_dopaminergic))

 
 #### Option 1 ####
# Create an empty list, and store VlnPlots in the list
#plot.list <- list()
#for (i in 1:length(Human_Nigra_dopaminergic_final)) {
  #plot.list[[i]] <- VlnPlot(object = sample_6_n3, features.plot = Human_Nigra_dopaminergic_final[i], do.return = T, do.sort=T)
#}
# Check elements of plot.list
#plot.list

#### Option 2 ####
# Directly print output of VlnPlot
#for (i in 1:length(genes.list)) {
  #print(VlnPlot(object = object, features.plot = genes.list[i]))
#}


# DA markers from neuorexpresso that are differentially expressed between clusters when looked at all markers
VlnPlot(object = Cortex.integrated, features.plot = c("ATP2B2","CD200","CELF4","CHGB","CLSTN2","CNTNAP2","ENO2","KLHL1","NAPB","HMP19","SCN1A","SLC4A10","SNCG","TENM1" ), nCol = 3, do.sort = T,point.size.use = 0)
#VlnPlot(object = sample_N4_N4B, features.plot = c(), nCol = 4, do.sort = T, use.raw=TRUE, y.log = T)
VlnPlot(object = Cortex.integrated, features.plot = c("ATP2B2","CD200","CELF4","CHGB","CLSTN2","CNTNAP2","ENO2","KLHL1","NAPB","HMP19","SCN1A","SLC4A10","SNCG","TENM1"), nCol = 3, do.sort = T, use.scaled=T, point.size.use = 0)
FeaturePlot(object = Cortex.integrated, features.plot =c ("ATP2B2","CD200","CELF4","CHGB","CLSTN2","CNTNAP2","ENO2","KLHL1","NAPB","HMP19","SCN1A","SLC4A10","SNCG","TENM1"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol = 3)

# 16 Reference DA neuron markers from Cythias DA iPSC paper
#VlnPlot(object = Cortex.integrated, features.plot = c("SOX6", "SLC18A2","MSX1","TH","EN1","LMX1A","DRD2","NR4A2","KCNJ6","SLC6A3"), nCol = 4, do.sort = T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("SOX6", "SLC18A2","MSX1","TH","LMX1A","DRD2","NR4A2","KCNJ6","SLC6A3"), nCol = 4, do.sort = T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("SOX6", "SLC18A2","MSX1","TH","LMX1A","DRD2","NR4A2","KCNJ6","SLC6A3"), nCol = 4, do.sort = T, use.scaled=T, point.size.use = 0)
FeaturePlot(object = Cortex.integrated, features.plot =c ("SOX6", "SLC18A2","MSX1","LMX1A","DRD2","NR4A2","KCNJ6","SLC6A3"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol=4)


```



# Neuron cell type markers Bin Zhang 2018 papers

```{r markerplots, fig.height=20, fig.width=15,}
#Human_Nigra_dopaminergic <- as.character(mouseHumanGeneTable_Nigra_Dopaminergic$humanGene)
#Human_Nigra_dopaminergic_final<- Reduce(intersect, list(all_genes,Human_Nigra_dopaminergic))

 
 #### Option 1 ####
# Create an empty list, and store VlnPlots in the list
#plot.list <- list()
#for (i in 1:length(Human_Nigra_dopaminergic_final)) {
  #plot.list[[i]] <- VlnPlot(object = sample_6_n3, features.plot = Human_Nigra_dopaminergic_final[i], do.return = T, do.sort=T)
#}
# Check elements of plot.list
#plot.list

#### Option 2 ####
# Directly print output of VlnPlot
#for (i in 1:length(genes.list)) {
  #print(VlnPlot(object = object, features.plot = genes.list[i]))
#}


# Neuron markers from Bin Zhang paper
VlnPlot(object = Cortex.integrated, features.plot = c("RELN","KCNC2", "GAD2", "SYNPR", "GAD1", "CNR1", "SYT1", "SCG2", "TAC3", "GABRG2", "GABRA1","STMN2","RBFOX3"), nCol = 3, do.sort = T, point.size.use = 0, x.lab.rot = T)
#VlnPlot(object = sample_N4_N4B, features.plot = c(), nCol = 4, do.sort = T, use.raw=TRUE, y.log = T)
VlnPlot(object = Cortex.integrated, features.plot = c("RELN","KCNC2", "GAD2", "SYNPR", "GAD1", "CNR1", "SYT1", "SCG2", "TAC3", "GABRG2", "GABRA1","STMN2","RBFOX3"), nCol = 3, do.sort = T, use.scaled=T, point.size.use = 0, x.lab.rot = T)
FeaturePlot(object = Cortex.integrated, features.plot =c ("RELN","KCNC2", "GAD2", "SYNPR", "GAD1", "CNR1", "SYT1", "SCG2", "TAC3", "GABRG2", "GABRA1","STMN2","RBFOX3"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol = 3)



```

# Identify  cell type markers between the two inhibitory neuron clusters
```{r}
cluster10vs0.markers <- FindMarkers(Cortex.integrated, ident.1 = 10, ident.2 = 0, test.use="negbinom",
    print.bar = T,min.pct = 0.25,only.pos = T)
#cluster7vs3.markers <- FindMarkers(Nigra.integrated, ident.1 = 7, ident.2 = 3, test.use="negbinom",
    #print.bar = T)
cluster11vs1.markers <- FindMarkers(Cortex.integrated, ident.1 = 11, ident.2 = 1, test.use="negbinom",
    print.bar = T,min.pct = 0.25,only.pos = T)
cluster0vs1.markers <- FindMarkers(Cortex.integrated, ident.1 = 0, ident.2 = 1, test.use="negbinom",
    print.bar = T,min.pct = 0.25,only.pos = T)
cluster17vs5.markers <- FindMarkers(Cortex.integrated, ident.1 =17 , ident.2 = 5, test.use="negbinom",
    print.bar = T,min.pct = 0.25,only.pos = T)
```

# Assiging cell types IDS and then decreasing resolution to see if that merges some clusters
### Assigning cell type identity to clusters
#Cell types for all clusters in a seperate excel sheet

```{r labelplot, fig.height=8, fig.width=20, warning = FALSE}
current.cluster.ids <- c(0, 1, 2, 3, 4, 5, 6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24)
#new.cluster.ids <- c("Neurons", "Neurons", "Neurons", "Neurons", "Neurons", "Neurons","Microglia","Astrocyte","Neurons","Neurons","Neurons","Neurons","Neurons","Neurons","Neurons","Neurons","OPC","Neurons","ODC","Neurons","Neurons","Neurons","Neurons","Neurons","Neurons")

#new.cluster.ids <- c("Pyramidal_Neurons", "Pyramidal_Neurons", "Pyramidal_Neurons", "Interneurons", "Interneurons", "Pyramidal_Neurons","Microglia","Astrocyte","Interneurons","Interneurons","Pyramidal_Neurons","Pyramidal_Neurons","Interneurons","Pyramidal_Neurons","Pyramidal_Neurons","Interneurons","OPC","Pyramidal_Neurons","ODC","Interneurons","Pyramidal_Neurons","Interneurons","Interneurons","Pyramidal_Neurons","Pyramidal_Neurons")


new.cluster.ids <- c("Ex2", "Ex1", "Ex5a", "In6B", "In1c", "Ex4","Microglia","Astrocyte","In8","In1b","Pyramidal_Neurons", "Ex5b","In4B","Ex6b","Ex4","In6B","OPC","Ex4","ODC","In6A","Ex6A","In1A","In4B","Ex8","Pyramidal_Neurons")

current.cluster.ids <- c("Astrocyte","Ex1","Ex2","Ex3","Ex4","Ex5a","Ex5b","Ex6A","Ex6b","Ex8","In1A", "In1b","In1c", "In3","In4A", "In4B","In5", "In6A", "In6B","In8", "Microglia", "ODC", "OPC")

new.cluster.ids <-  c("Astrocyte","Pyramidal_Neurons","Pyramidal_Neurons","Pyramidal_Neurons","Pyramidal_Neurons","Pyramidal_Neurons","Pyramidal_Neurons","Pyramidal_Neurons","Pyramidal_Neurons","Pyramidal_Neurons","Interneurons", "Interneurons","Interneurons", "Interneurons","Interneurons", "Interneurons","Interneurons", "Interneurons", "Interneurons","Interneurons", "Microglia", "ODC", "OPC")

Cortex.integrated@ident <- plyr::mapvalues(x = Cortex.integrated@ident, from = current.cluster.ids, to = new.cluster.ids)
#Cortex.integrated <- StashIdent(object = Cortex.integrated, save.name = "ClusterNames_0.8_level_2")
Cortex.integrated <- StashIdent(object = Cortex.integrated, save.name = "ClusterNames_0.8_level1")

#p1 <-TSNEPlot(object = sample_Nigra, do.label = TRUE, pt.size = 2.0,do.return=T)
#p2 <-TSNEPlot(object = sample_Nigra, do.label = TRUE, pt.size = 2.0, do.return=T, group.by="res.0.6")
#p3 <- TSNEPlot(object = sample_Nigra, pt.size = 2.0, do.return=T, group.by="samples")
#p4 <-TSNEPlot(object = sample_Nigra, do.label = TRUE, pt.size = 2.0, do.return=T, group.by="res.0.6",pt.shape="samples")
#plot_grid(p1,p2)
#plot_grid(p2,p3)
#plot_grid(p1,p3)
#plot_grid(p1,p4)
metadata <- as.data.frame(Cortex.integrated@meta.data)
write.table(metadata, file="Cortex_10x_CCA_metadata.txt", sep="\t", quote=F)

metadata <- Cortex.integrated_v3@meta.data
metadata$ClusterNames_0.8_level1 <- as.factor(metadata$ClusterNames_0.8_level1)
levels(metadata$ClusterNames_0.8_level1)[levels(metadata$ClusterNames_0.8_level1)=="Ex_Neurons"] <- "Ex Neurons"

levels(metadata$ClusterNames_0.8_level1)[levels(metadata$ClusterNames_0.8_level1)=="In_Neurons"] <- "In Neurons"

Cortex.integrated_v3@meta.data <- metadata
```

# Manually rename some cells as potential microglial cluster 2
```{r}
cell_id <- read.table(file="./Cortex_microglial_cluster2_ids.txt", sep="\t", header=T)

microglial_2 <- as.vector(cell_id$select.cells)


Cortex.integrated_v3 <- SetIdent(object = Cortex.integrated_v3, cells = microglial_2, value =  "Microglia-2")
Idents(object=Cortex.integrated_v3) <- "ClusterNames_0.8_level1_v2"

#DaN_DAT_L <- as.vector(DaN_id$DaNeurons_GT_DAT_low)


```




# TSNE plot with cell counts for each sample in a cluster
```{r, fig.width=3.7, fig.height=2.5}
#col.pal <- RColorBrewer::brewer.pal(11,name= "BuGn")
#qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
library(RColorBrewer)

tiff(filename = "/Volumes/Seagate Backup Plus Drive/Oxford_postdoc/10x_scN_tara_human/Samples_merged/Cortex_Merged_CCA/Cortex_L1_tsne.tiff", width =9, height = 5,res = 300, unit="cm")
# Calculate number of cells per cluster from object@ident
cell.num <- table(Cortex.integrated_v3@meta.data$ClusterNames_0.8_level1)

# Add cell number per cluster to cluster labels
ClusterLabels = paste(names(cell.num), paste0("(n = ", cell.num, ")"))

# Order legend labels in plot in the same order as 'ClusterLabels'
ClusterBreaks = names(cell.num)
colourCount = length(unique(cell.num))
#getPalette = colorRampPalette(brewer.pal(11, "Set2"))
# Plot tSNE with new legend labels for clusters
cortex_tsne <- TSNEPlot(object = Cortex.integrated_v3, do.return = T,  pt.size = 0.1, label = F, group.by="ClusterNames_0.8_level1", label.size=2,no.legend=F, no.axes=T, repel=T) 
cortex_tsne <- cortex_tsne +  scale_colour_manual(breaks = ClusterBreaks, 
                        labels = ClusterLabels, values=c("ODC"="#00B0F6","OPC"="#E76BF3", "Ex Neurons"="#39B600","In Neurons"="#CF9400", "Microglia"="#00BFC4","Astrocyte"="#F8766D")) 
#p1 <- p1+ labs(x = "t-SNE 1",
      # y = "t-SNE 2")
#p1 <- p1 + theme(legend.text=element_text(size=16))
#p1 <- p1 + theme(legend.text=element_text(size=16))
cortex_tsne <- cortex_tsne +ggtitle("Cortex(n=10,706)") + theme(plot.title = element_text(hjust = 0.5, size=5, face="bold"))
cortex_tsne <- cortex_tsne + theme(legend.text=element_text(size=4)) + theme(legend.key.size = unit(0.5, 'lines')) + theme(legend.margin=margin(0,0,0,0),
        legend.box.spacing = unit(0.1,'cm'),legend.spacing.x  = unit(0.05,'cm'))
cortex_tsne <- cortex_tsne +  theme(axis.line=element_blank(),axis.text.x=(element_blank()), axis.text.y=element_blank(),axis.ticks=element_blank(),
      axis.title.x=element_blank(),axis.title.y=element_blank(),panel.background=element_blank())
#cortex_tsne <- cortex_tsne + guides(color = guide_legend(override.aes = list(size=3)))      
#cortex_tsne <- cortex_tsne + theme(legend.position="bottom")
cortex_tsne

library(RColorBrewer)
#tiff(filename = "C:/Users/dagarwal/Documents/10x_scN_tara_human/Samples_merged/Cortex_Merged_CCA/Cortex_celltypes_l2.tiff", width = 8, height = 6,res = 300, unit="in")
# Calculate number of cells per cluster from object@ident
cell.num <- table(Cortex.integrated_v3@meta.data$ClusterNames_0.8_level_2)

# Add cell number per cluster to cluster labels
ClusterLabels = paste("Cluster",names(cell.num), paste0("(n = ", cell.num, ")"))

# Order legend labels in plot in the same order as 'ClusterLabels'
ClusterBreaks = names(cell.num)
colourCount = length(unique(cell.num))
#getPalette = colorRampPalette(brewer.pal(11, "Set2"))
# Plot tSNE with new legend labels for clusters
cortex_tsne <- DimPlot(object = Cortex.integrated_v3,  pt.size = 0.8, label = T, group.by="ClusterNames_0.8_level_2", label.size = 2, reduction="tsne") + NoAxes() + NoLegend()
cortex_tsne <- cortex_tsne +  scale_colour_manual(breaks = ClusterBreaks, 
                        labels = ClusterLabels, values=c("ODC"="#00B0F6","OPC"="#E76BF3", "Ex1"="#6BB100", "Ex2"="#39B600","Ex3"="#00BA38","Ex4"="#00BA38","Ex5a"="#00BD5F","Ex5b"="#00BD5F","Ex6A"="#00BD5F","Ex6b"="#00BD5F","Ex8"="#00BD5F", "In1A"="#CF9400", "Microglia"="#00BFC4","Astrocyte"="#F8766D", "In1b"="#CF9400","In1c"="#CF9400", "In3"= "#CF9400","In4A"="#CF9400", "In4B"="#CF9400","In5"="#E58700", "In6A"="#C99800", "In6B"="#C99800", "In8"="#C99800")) 
#p1 <- p1+ labs(x = "t-SNE 1",
      # y = "t-SNE 2")
#p1 <- p1 + theme(legend.text=element_text(size=16))
cortex_tsne <- cortex_tsne +ggtitle("Cortex(n=10,706)") + theme(plot.title = element_text(hjust = 0.5, size=6, face="bold"))
cortex_tsne






cell.num <- table(Cortex.integrated@meta.data$sample)

# Add cell number per cluster to cluster labels
ClusterLabels = paste("Sample",names(cell.num), paste0("(n = ", cell.num, ")"))

# Order legend labels in plot in the same order as 'ClusterLabels'
ClusterBreaks = names(cell.num)
colourCount = length(unique(cell.num))
getPalette = colorRampPalette(brewer.pal(11, "Set1"))
# Plot tSNE with new legend labels for clusters
cortex_sample <- TSNEPlot(object = Cortex.integrated, do.return = T,  pt.size = 0.8, group.by="sample", no.axes=T, do.label = F) 
cortex_sample <- cortex_sample +  scale_colour_manual(breaks = ClusterBreaks, 
                        labels = ClusterLabels, values=getPalette(colourCount)) 
#p2 <- p2+ labs(x = "t-SNE 1",
  #     y = "t-SNE 2")
cortex_sample <- cortex_sample +ggtitle("Sample") + theme(plot.title = element_text(hjust = 0.5, size=6, face="bold"))
cortex_sample <- cortex_sample + guides(color = guide_legend(override.aes = list(size=4), nrow = 2))
cortex_sample <- cortex_sample + theme(legend.text=element_text(size=5))
cortex_sample <- cortex_sample + theme(legend.position="bottom")
cortex_sample

#table(sample_Nigra@ident, sample_Nigra@meta.data$samples)
#sample_Nigra@meta.data$nUMIcat <-cut(sample_Nigra@meta.data$nUMI, breaks= c(0,4000,8000,12000,16000,20000,24000,28000,32000,Inf), labels=c( "2k","4k","8k","12k","16k","20k","24k","28k","32k"),right=FALSE)

#colourCount=11
#getPalette = colorRampPalette(brewer.pal(11, "BuGn"))

cortex_umi <- ggplot(Cortex.integrated_tSNE, aes(x= tSNE_1, y=tSNE_2))
cortex_umi <- cortex_umi +geom_point(size=0.8, aes(colour=nUMI)) 
cortex_umi <- cortex_umi +theme_bw(base_size=5)
cortex_umi <- cortex_umi +  scale_color_gradientn(colors = brewer.pal(6,"Reds"),limits=c(500,75000), guide = "colourbar") 
cortex_umi <- cortex_umi +ggtitle("UMI depth") + theme(plot.title = element_text(hjust = 0.5, size=6, face="bold"))
cortex_umi <- cortex_umi + theme(axis.line=element_blank(),axis.text.x=element_blank(), axis.text.y=element_blank(),axis.ticks=element_blank(),
      axis.title.x=element_blank(),axis.title.y=element_blank(),panel.background=element_blank(),
      panel.border=element_blank(),
      panel.grid.major=element_blank(),
      panel.grid.minor=element_blank(),
      plot.background=element_blank())
cortex_umi <- cortex_umi + theme(legend.text=element_text(size=5))
cortex_umi <- cortex_umi + guides(color = guide_legend(override.aes = list(size=4)))                                 
cortex_umi <- cortex_umi + theme(legend.position="bottom")
cortex_umi

cortex_gene <- ggplot(Cortex.integrated_tSNE, aes(x= tSNE_1, y=tSNE_2))
cortex_gene <- cortex_gene +geom_point(size=0.8, aes(colour=nGene)) 
cortex_gene <- cortex_gene +theme_bw(base_size=5)
cortex_gene <- cortex_gene +  scale_color_gradientn(colors = brewer.pal(6,"Reds"),limits=c(500,12000), guide = "colourbar") 
cortex_gene <- cortex_gene +ggtitle("No of genes") + theme(plot.title = element_text(hjust = 0.5, size=6, face="bold"))
cortex_gene <- cortex_gene + theme(axis.line=element_blank(),axis.text.x=element_blank(), axis.text.y=element_blank(),axis.ticks=element_blank(),
      axis.title.x=element_blank(),axis.title.y=element_blank(),panel.background=element_blank(),
      panel.border=element_blank(),
      panel.grid.major=element_blank(),
      panel.grid.minor=element_blank(),
      plot.background=element_blank())
cortex_gene <- cortex_gene + theme(legend.text=element_text(size=5))
cortex_gene <- cortex_gene + guides(color = guide_legend(override.aes = list(size=4)))                                 
cortex_gene <- cortex_gene + theme(legend.position="bottom")
cortex_gene


cell.num <- table(Cortex.integrated@meta.data$Phase)

# Add cell number per cluster to cluster labels
ClusterLabels = paste("Phase",names(cell.num), paste0("(n = ", cell.num, ")"))

# Order legend labels in plot in the same order as 'ClusterLabels'
ClusterBreaks = names(cell.num)
colourCount = length(unique(cell.num))
getPalette = colorRampPalette(brewer.pal(11, "Set1"))
# Plot tSNE with new legend labels for clusters
cortex_phase <- TSNEPlot(object = Cortex.integrated, do.return = T,  pt.size = 0.8, group.by="Phase", no.axes=T, do.label=F) 
cortex_phase <- cortex_phase +  scale_colour_manual(breaks = ClusterBreaks, 
                        labels = ClusterLabels, values=getPalette(colourCount)) 
#p4 <- p4+ labs(x = "t-SNE 1",
     #  y = "t-SNE 2")
cortex_phase <- cortex_phase +ggtitle("Cell cycle phase") + theme(plot.title = element_text(hjust = 0.5, size=6, face="bold"))
cortex_phase <- cortex_phase + theme(legend.text=element_text(size=5))
cortex_phase <- cortex_phase + theme(legend.position="bottom")
cortex_phase <- cortex_phase + guides(color = guide_legend(override.aes = list(size=4)))  
cortex_phase


cell.num <- table(Cortex.integrated@meta.data$batch)
# Add cell number per cluster to cluster labels
ClusterLabels = paste(names(cell.num), paste0("(n = ", cell.num, ")"))

# Order legend labels in plot in the same order as 'ClusterLabels'
ClusterBreaks = names(cell.num)
colourCount = length(unique(cell.num))
getPalette = colorRampPalette(brewer.pal(11, "Set1"))
# Plot tSNE with new legend labels for clusters
cortex_batch <- TSNEPlot(object = Cortex.integrated, do.return = T,  pt.size = 0.8, group.by="batch",no.axes=T, do.label = F) 
cortex_batch <- cortex_batch +  scale_colour_manual(breaks = ClusterBreaks, 
                        labels = ClusterLabels, values=getPalette(colourCount)) 
#p4 <- p4+ labs(x = "t-SNE 1",
#       y = "t-SNE 2")
cortex_batch <- cortex_batch +ggtitle("Batch") + theme(plot.title = element_text(hjust = 0.5, size=6, face="bold"))
cortex_batch <- cortex_batch + theme(legend.text=element_text(size=5))
cortex_batch <- cortex_batch + theme(legend.position="bottom")
cortex_batch <- cortex_batch + guides(color = guide_legend(override.aes = list(size=4)))  
cortex_batch





```


```{r, fig.width=7, fig.height=8}
tiff(filename = "F:/Oxford_postdoc/10x_scN_tara_human/Samples_merged/Cortex_Merged_CCA/Cortex_metrics_l2.tiff", width = 17.8, height = 18,res = 300, unit="cm")
plot_grid(cortex_tsne,cortex_batch,cortex_sample,cortex_phase, cortex_umi,cortex_gene, label_size = 8, labels= "auto",align = "hv", ncol = 2, axis = "tb")

```
# Run UMAP on same dimensions as  Tsne
```{r}
Cortex.integrated <- RunUMAP(Cortex.integrated,
                               reduction.use = "cca.aligned",
                               dims.use = 1:42)
```

# TSNE plot with cell counts for each sample in a cluster
```{r, fig.width=12, fig.height=6}
#col.pal <- RColorBrewer::brewer.pal(11,name= "BuGn")
#qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
library(RColorBrewer)

# Calculate number of cells per cluster from object@ident
cell.num <- table(Cortex.integrated@meta.data$ClusterNames_0.8_level_2)

# Add cell number per cluster to cluster labels
ClusterLabels = paste("Cluster",names(cell.num), paste0("(n = ", cell.num, ")"))

# Order legend labels in plot in the same order as 'ClusterLabels'
ClusterBreaks = names(cell.num)
colourCount = length(unique(cell.num))
getPalette = colorRampPalette(brewer.pal(11, "Set2"))
# Plot tSNE with new legend labels for clusters
p1 <- DimPlot(object = Cortex.integrated, do.return = T,  pt.size = 0.5, do.label = T, group.by="ClusterNames_0.8_level_2", reduction.use="umap", label.size = 5) 
#p1 <- p1 +  scale_colour_manual(breaks = ClusterBreaks, 
                        #labels = ClusterLabels, values=getPalette(colourCount)) 
p1 <- p1+ labs(x = "UMAP1",
       y = "UMAP2")
#p1 <- p1 + theme(legend.text=element_text(size=16))
p1

# Calculate number of cells per cluster from object@ident
cell.num <- table(Cortex.integrated@meta.data$ClusterNames_0.8_level1)

# Add cell number per cluster to cluster labels
ClusterLabels = paste("Cluster",names(cell.num), paste0("(n = ", cell.num, ")"))

# Order legend labels in plot in the same order as 'ClusterLabels'
ClusterBreaks = names(cell.num)
colourCount = length(unique(cell.num))
getPalette = colorRampPalette(brewer.pal(11, "Set2"))
# Plot tSNE with new legend labels for clusters
p1 <- DimPlot(object = Cortex.integrated, do.return = T,  pt.size = 1.0, do.label = T, group.by="ClusterNames_0.8_level1", reduction.use = "umap", label.size = 5) 
p1 <- p1 +  scale_colour_manual(breaks = ClusterBreaks, 
                        labels = ClusterLabels, values=getPalette(colourCount)) 
p1 <- p1+ labs(x = "UMAP1",
       y = "UMAP2")
p1 <- p1 + theme(legend.text=element_text(size=16))
p1






cell.num <- table(Cortex.integrated@meta.data$sample)

# Add cell number per cluster to cluster labels
ClusterLabels = paste("Sample",names(cell.num), paste0("(n = ", cell.num, ")"))

# Order legend labels in plot in the same order as 'ClusterLabels'
ClusterBreaks = names(cell.num)
colourCount = length(unique(cell.num))
getPalette = colorRampPalette(brewer.pal(11, "Set1"))
# Plot tSNE with new legend labels for clusters
p2 <- DimPlot(object = Cortex.integrated, do.return = T,  pt.size = 1.0, group.by="sample", reduction.use = "umap") 
p2 <- p2 +  scale_colour_manual(breaks = ClusterBreaks, 
                        labels = ClusterLabels, values=getPalette(colourCount)) 
p2 <- p2+ labs(x = "UMAP1",
       y = "UMAP2")
p2 <- p2 + theme(legend.text=element_text(size=16))
p2



cell.num <- table(Cortex.integrated@meta.data$Phase)

# Add cell number per cluster to cluster labels
ClusterLabels = paste("Phase",names(cell.num), paste0("(n = ", cell.num, ")"))

# Order legend labels in plot in the same order as 'ClusterLabels'
ClusterBreaks = names(cell.num)
colourCount = length(unique(cell.num))
getPalette = colorRampPalette(brewer.pal(11, "Set1"))
# Plot tSNE with new legend labels for clusters
p4 <- DimPlot(object = Cortex.integrated, do.return = T,  pt.size = 1.0, group.by="Phase", reduction.use = "umap") 
p4 <- p4 +  scale_colour_manual(breaks = ClusterBreaks, 
                        labels = ClusterLabels, values=getPalette(colourCount)) 
p4 <- p4+ labs(x = "UMAP1",
       y = "UMAP2")
p4 <- p4 + theme(legend.text=element_text(size=16))
p4


cell.num <- table(Cortex.integrated@meta.data$batch)
# Add cell number per cluster to cluster labels
ClusterLabels = paste(names(cell.num), paste0("(n = ", cell.num, ")"))

# Order legend labels in plot in the same order as 'ClusterLabels'
ClusterBreaks = names(cell.num)
colourCount = length(unique(cell.num))
getPalette = colorRampPalette(brewer.pal(11, "Set1"))
# Plot tSNE with new legend labels for clusters
p4 <- DimPlot(object = Cortex.integrated, do.return = T,  pt.size = 1.0, group.by="batch", reduction.use="umap") 
p4 <- p4 +  scale_colour_manual(breaks = ClusterBreaks, 
                        labels = ClusterLabels, values=getPalette(colourCount)) 
p4 <- p4+ labs(x = "UMAP1",
       y = "UMAP2")
p4 <- p4 + theme(legend.text=element_text(size=16))
p4




```


# final vln and feature plot for each cell type based on gene.set scores
```{r, fig.height=16, fig.width=13}
VlnPlot(object = Cortex.integrated, features.plot = c("gene_set_astrocyte_score","gene_set_microglia_score","gene_set_odc_score","gene_set_endothelial_score","gene_set_opc_score" ,"gene_set_Pyramidal_score", "gene_set_gaba_pv_score","gene_set_microglia_activation_score","gene_set_microglia_deactivation_score"), nCol = 2, do.sort = T, use.scaled=T, x.lab.rot = T, point.size.use = 0)
VlnPlot(object = Cortex.integrated, features.plot = c("gene_set_astrocyte_score","gene_set_microglia_score","gene_set_odc_score","gene_set_endothelial_score","gene_set_opc_score" ,"gene_set_Pyramidal_score", "gene_set_gaba_pv_score","gene_set_microglia_activation_score","gene_set_microglia_deactivation_score"), nCol = 2, do.sort = T, use.scaled=T, x.lab.rot = T, group.by="sample", point.size.use = 0)
FeaturePlot(object = Cortex.integrated, features.plot =c("gene_set_astrocyte_score","gene_set_microglia_score","gene_set_odc_score","gene_set_endothelial_score","gene_set_opc_score" ,"gene_set_Pyramidal_score", "gene_set_gaba_pv_score","gene_set_microglia_activation_score","gene_set_microglia_deactivation_score"), cols.use = c("grey", "red"), reduction.use = "tsne", nCol = 2)
```



```{r, fig.height=8, fig.width=12}
#col.pal <- RColorBrewer::brewer.pal(11,name= "Set1")
markers.to.plot <- c("NEUROD6","SATB2","SLC17A7","AQP4","GFAP","CSF3R","MOG","MOBP","GAD1","GAD2","CCK","CNR1","C8orf34","THSD7B","VIP","TAC3","CALB2","RYR3","THSD7A","COL5A2","SV2C","EYA4","NOS1","SULF1","PVALB","CA8","RYR1","TAC1","CRHBP","CALB1","NPY","SST","STXBP6","RASGRF2","CUX2","LAMA2","NEFM","PTPRD","TENM2","TOX","SLC22A10","PCP4","TMSB10","HS3ST2","PDZRN4","TLE4","HS3ST4","SEMA3D","MCTP2","NTNG2","OLIG1","VCAN")
markers.to.plot_1 <- c("gene_set_astrocyte_score","gene_set_microglia_score","gene_set_odc_score","gene_set_endothelial_score","gene_set_opc_score" ,"gene_set_Pyramidal_score", "gene_set_gaba_pv_score","gene_set_microglia_activation_score","gene_set_microglia_deactivation_score")
DotPlot(Cortex.integrated, genes.plot = markers.to.plot, plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
DotPlot(Cortex.integrated, genes.plot = markers.to.plot_1, plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
```
```{r, fig.height=6, fig.width=8}
FeaturePlot(object = Cortex.integrated, features.plot =c("RND2"), cols.use = c("grey", "red"), reduction.use = "tsne")
DotPlot(Cortex.integrated, genes.plot = "RND2", plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
VlnPlot(object = Cortex.integrated, features.plot = c("RND2"), do.sort = T, use.scaled=T, x.lab.rot = T)
```

```{r}
Cortex_cluster_numbers <-  data.frame(table(Cortex.integrated@meta.data$ClusterNames_0.8_level1, Cortex.integrated@meta.data$sample))
library(tidyr)
Cortex_cluster_no_wide <- spread(Cortex_cluster_numbers,Var2,Freq)
write.table(Cortex_cluster_no_wide, file="Cortex_10x_CCA_cluster_frequency_level1_wide.txt", sep="\t",quote=F)
prop.table(x = table(Cortex.integrated@ident, Cortex.integrated@meta.data$sample), margin = 2)
```

#Boxplots for celltype vs nUMI
```{r}
metadata <- data.frame(Cortex.integrated_v3@meta.data)
metadata <- metadata[,c(1,2,3,6,7,8,9,16,17)]
#rownames(metadata) <- metadata$X
metadata <- as.data.table(metadata)
rownames(metadata) <- metadata$X
plot_data <- melt(metadata, id=c( "ClusterNames_0.8_level1"), measure=c("nUMI"))
plot_data$ClusterNames_0.8_level1 <- as.factor(plot_data$ClusterNames_0.8_level1)
levels(plot_data$ClusterNames_0.8_level1)[levels(plot_data$ClusterNames_0.8_level1)=="Ex Neurons"] <- "Ex neurons"
levels(plot_data$ClusterNames_0.8_level1)[levels(plot_data$ClusterNames_0.8_level1)=="In Neurons"] <- "In neurons"
```

# nUMI plot
```{r mapping_stats_2_plot, fig.height=2.5, fig.width=3.5}
library(Seurat)
library(ggplot2)

umi_plot <- ggplot(plot_data, aes(x=ClusterNames_0.8_level1, y=value, fill=ClusterNames_0.8_level1))
umi_plot <- umi_plot + geom_violin(trim = T, scale="width")
 umi_plot <- umi_plot + stat_summary(fun.y=median, geom="point", size=1.0, color="black")
#p <- p + ggbeeswarm::geom_quasirandom(aes(colour= ClusterNames_0.8_level1), size=0.7, alpha=0.7)
umi_plot <- umi_plot + scale_fill_manual(values=c("ODC"="#00B0F6","OPC"="#E76BF3", "Ex neurons"="#39B600","In neurons"="#CF9400", "Microglia"="#00BFC4","Astrocyte"="#F8766D"))
umi_plot <- umi_plot + theme(axis.text.x = element_text(angle=32,hjust=1, size=6)) + theme(axis.text.y = element_text(size=6))+ theme(axis.title.y = element_text(size=7)) +theme(axis.title.x = element_text(size=7))
umi_plot <- umi_plot  +ggtitle("nUMI depth") + theme(plot.title = element_text(hjust = 0.5, size=6, face="bold"))
#umi_plot <- umi_plot + guides(color = guide_legend(override.aes = list(size=3), nrow = 2))
umi_plot <-  umi_plot + theme(legend.text=element_text(size=5)) + theme(legend.title=element_text(size=6))
umi_plot <- umi_plot + theme(legend.position="none")
umi_plot <- umi_plot + xlab("") + ylab("nUMI")
umi_plot 


```
#Boxplots for celltype vs nGene
```{r}
#metadata <- as.data.frame(Cortex.integrated@meta.data)
#metadata <- metadata[,c(1,2,6,7,8,9,10,22,25)]
#metadata <- as.data.table(metadata)
plot_data <- melt(metadata, id=c( "ClusterNames_0.8_level1"), measure=c("nGene"))
plot_data$ClusterNames_0.8_level1 <- as.factor(plot_data$ClusterNames_0.8_level1)
levels(plot_data$ClusterNames_0.8_level1)[levels(plot_data$ClusterNames_0.8_level1)=="Ex Neurons"] <- "Ex neurons"
levels(plot_data$ClusterNames_0.8_level1)[levels(plot_data$ClusterNames_0.8_level1)=="In Neurons"] <- "In neurons"
```

# nGene plot
```{r mapping_stats_2_plot, fig.height=2.5, fig.width=3.5}

ngene_plot <- ggplot(plot_data, aes(x=ClusterNames_0.8_level1, y=value, fill=ClusterNames_0.8_level1))
ngene_plot <-ngene_plot + geom_violin(trim = T, scale="width")
ngene_plot <- ngene_plot + stat_summary(fun.y=median, geom="point", size=1.0, color="black")
#p <- p + ggbeeswarm::geom_quasirandom(aes(colour= ClusterNames_0.8_level1), size=0.7, alpha=0.7)
ngene_plot <- ngene_plot + scale_fill_manual(values=c("ODC"="#00B0F6","OPC"="#E76BF3", "Ex neurons"="#39B600","In neurons"="#CF9400", "Microglia"="#00BFC4","Astrocyte"="#F8766D"))
ngene_plot <- ngene_plot + theme(axis.text.x = element_text(angle=32,hjust=1, size=6)) + theme(axis.text.y = element_text(size=6))+ theme(axis.title.y = element_text(size=7)) +theme(axis.title.x = element_text(size=7))
ngene_plot <- ngene_plot  +ggtitle("Gene coverage") + theme(plot.title = element_text(hjust = 0.5, size=6, face="bold"))
#umi_plot <- umi_plot + guides(color = guide_legend(override.aes = list(size=3), nrow = 2))
ngene_plot <-  ngene_plot + theme(legend.text=element_text(size=5)) + theme(legend.title=element_text(size=6))
ngene_plot <- ngene_plot + theme(legend.position="none")
ngene_plot <- ngene_plot + xlab("") + ylab("nGene")
ngene_plot 


```








# get average of all covariates for cortex cell types level 1
```{r}
library (dplyr)

metadata_short <- Cortex.integrated@meta.data  %>% group_by(ClusterNames_0.8_level1) %>% summarise(nUMI= median(nUMI), nGene=median(nGene))

```


```{r}
metadata_short <- Cortex.integrated_v3@meta.data %>% group_by(ClusterNames_0.8_level1, sample) %>% summarise(tot.per.sample=n())%>% group_by(ClusterNames_0.8_level1) %>%
  mutate(tot.cluster.pt= sum(tot.per.sample)) %>%
  mutate(percent=100*tot.per.sample/tot.cluster.pt)

setnames(metadata_short, "sample", "Sample")
metadata_short$ClusterNames_0.8_level1 <- as.factor(metadata_short$ClusterNames_0.8_level1)
levels(metadata_short$ClusterNames_0.8_level1)[levels(metadata_short$ClusterNames_0.8_level1)=="Ex Neurons"] <- "Ex neurons"
levels(metadata_short$ClusterNames_0.8_level1)[levels(metadata_short$ClusterNames_0.8_level1)=="In Neurons"] <- "In neurons"
```

```{r , fig.height=2.6, fig.width=3.5}
library(RColorBrewer)
sample_plot <- ggplot(metadata_short, aes(ClusterNames_0.8_level1, percent, fill=Sample)) 
sample_plot <- sample_plot +geom_bar(stat="identity", position="stack", colour ="black", width=0.6)  + scale_fill_brewer(palette="Set1")
sample_plot <- sample_plot + theme(axis.text.x = element_text(angle=32,hjust=1, size=6)) + theme(axis.text.y = element_text(size=6))+ theme(axis.title.y = element_text(size=7)) +theme(axis.title.x = element_text(size=7))
sample_plot <- sample_plot  +ggtitle("Sample proportions") + theme(plot.title = element_text(hjust = 0.5, size=6, face="bold"))
sample_plot <- sample_plot + guides(color = guide_legend(override.aes = list(size=3), nrow = 2))
sample_plot <-  sample_plot + theme(legend.text=element_text(size=6)) + theme(legend.title=element_text(size=7))
sample_plot <- sample_plot + theme(legend.position="right")
sample_plot <- sample_plot + xlab("") + ylab("Percent")
sample_plot 
```
# Batch plot
```{r}
library (dplyr)

metadata_short <- Cortex.integrated_v3@meta.data %>% group_by(ClusterNames_0.8_level1, batch) %>% summarise(tot.per.batch=n())%>% group_by(ClusterNames_0.8_level1) %>%
  mutate(tot.cluster.pt= sum(tot.per.batch)) %>%
  mutate(percent=100*tot.per.batch/tot.cluster.pt)

setnames(metadata_short, "batch", "Batch")
metadata_short$ClusterNames_0.8_level1 <- as.factor(metadata_short$ClusterNames_0.8_level1)
levels(metadata_short$ClusterNames_0.8_level1)[levels(metadata_short$ClusterNames_0.8_level1)=="Ex Neurons"] <- "Ex neurons"
levels(metadata_short$ClusterNames_0.8_level1)[levels(metadata_short$ClusterNames_0.8_level1)=="In Neurons"] <- "In neurons"
```

```{r , fig.height=2.6, fig.width=3.5}
library(RColorBrewer)
batch_plot <- ggplot(metadata_short, aes(ClusterNames_0.8_level1, percent, fill=Batch)) 
batch_plot <- batch_plot +geom_bar(stat="identity", position="stack", colour ="black", width = 0.6)  + scale_fill_brewer(palette="Set1")
batch_plot <- batch_plot + theme(axis.text.x = element_text(angle=32,hjust=1, size=6)) + theme(axis.text.y = element_text(size=6))+ theme(axis.title.y = element_text(size=7)) +theme(axis.title.x = element_text(size=7))
batch_plot <- batch_plot  +ggtitle("Batch proportions") + theme(plot.title = element_text(hjust = 0.5, size=6, face="bold"))
batch_plot <- batch_plot + guides(color = guide_legend(override.aes = list(size=3), nrow = 2))
batch_plot <-  batch_plot + theme(legend.text=element_text(size=6)) + theme(legend.title=element_text(size=7))
batch_plot <-  batch_plot + theme(legend.position="right")
batch_plot <- batch_plot + xlab("") + ylab("Percent")
batch_plot 
```
# Cell Cycle Phase proportions
```{r}
library (dplyr)

metadata_short <- Cortex.integrated@meta.data %>% group_by(ClusterNames_0.8_level1, Phase) %>% summarise(tot.per.phase=n())%>% group_by(ClusterNames_0.8_level1) %>%
  mutate(tot.cluster.pt= sum(tot.per.phase)) %>%
  mutate(percent=100*tot.per.phase/tot.cluster.pt)

#setnames(metadata_short, "batch", "Batch")
metadata_short$ClusterNames_0.8_level1 <- as.factor(metadata_short$ClusterNames_0.8_level1)
levels(metadata_short$ClusterNames_0.8_level1)[levels(metadata_short$ClusterNames_0.8_level1)=="Pyramidal_Neurons"] <- "Ex neurons"
levels(metadata_short$ClusterNames_0.8_level1)[levels(metadata_short$ClusterNames_0.8_level1)=="Interneurons"] <- "In neurons"
```

```{r , fig.height=2.6, fig.width=3.5}
library(RColorBrewer)
phase_plot <- ggplot(metadata_short, aes(ClusterNames_0.8_level1, percent, fill=Phase)) 
phase_plot <- phase_plot +geom_bar(stat="identity", position="stack", colour ="black", width=0.8)  + scale_fill_brewer(palette="Set1")
phase_plot <- phase_plot + theme(axis.text.x = element_text(angle=32,hjust=1, size=6)) + theme(axis.text.y = element_text(size=6))+ theme(axis.title.y = element_text(size=7)) +theme(axis.title.x = element_text(size=7))
phase_plot <- phase_plot  +ggtitle("Cell-cycle phase") + theme(plot.title = element_text(hjust = 0.5, size=6, face="bold"))
phase_plot <- phase_plot + guides(color = guide_legend(override.aes = list(size=3), nrow = 2))
phase_plot <-  phase_plot + theme(legend.text=element_text(size=6)) + theme(legend.title=element_text(size=7))
phase_plot <-  phase_plot + theme(legend.position="right")
phase_plot <- phase_plot + xlab("") + ylab("Percent")
phase_plot 
```

```{r, fig.width=7, fig.height=8}
library(cowplot)
tiff(filename = "/Volumes/Seagate Backup Plus Drive/Oxford_postdoc/10x_scN_tara_human/Samples_merged/Cortex_Merged_CCA/Cortex_metrics_l2_v3.tiff", width = 17.8, height = 20,res = 300, unit="cm")
plot_grid(cortex_tsne,batch_plot,sample_plot,umi_plot,ngene_plot, label_size = 8, labels= "auto",align = "hv", ncol = 2, axis = "tb")

```



```{r}
normalised_data_cortex.integrated <- as.matrix(Cortex.integrated@data)
scaled_data_cortex <- as.data.frame(Cortex.integrated@scale.data)
metadata_cortex.integrated <- as.data.frame(Cortex.integrated@meta.data)
metadata_cortex.integrated$cellnames <- rownames(metadata_cortex.integrated)
rawdata <- as.matrix(Cortex.integrated@raw.data)
rawdata_subset <- subset(rawdata, select= metadata_cortex.integrated$cellnames)
rawdata_subset <- as.data.frame(rawdata_subset)
write.table(scaled_data_cortex, file="10x_Cortex_CCA_scaled_data_allsamples.txt",sep="\t", quote=F)
write.table(rawdata_subset, file="10X_Cortex_rawdata_allsamples.txt", sep="\t", quote=F)
```


#Cluster Averages heatmap and dotplot, for marker genes and TOP PC genes

```{r, fig.height=8}
markers.to.plot <- c("NEUROD6","SATB2","SLC17A7","AQP4","GFAP","CSF3R","MOG","MOBP","GAD1","GAD2","CCK","CNR1","C8orf34","THSD7B","VIP","TAC3","CALB2","RYR3","THSD7A","COL5A2","SV2C","EYA4","NOS1","SULF1","PVALB","CA8","RYR1","TAC1","CRHBP","CALB1","NPY","SST","STXBP6","RASGRF2","CUX2","LAMA2","NEFM","PTPRD","TENM2","TOX","SLC22A10","PCP4","TMSB10","HS3ST2","PDZRN4","TLE4","HS3ST4","SEMA3D","MCTP2","NTNG2","OLIG1","VCAN")
markers.to.plot_1 <- c("gene_set_astrocyte_score","gene_set_microglia_score","gene_set_odc_score","gene_set_endothelial_score","gene_set_opc_score" ,"gene_set_Pyramidal_score", "gene_set_gaba_pv_score","gene_set_microglia_activation_score","gene_set_microglia_deactivation_score")
DotPlot(cluster.averages, genes.plot = markers.to.plot, plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
DotPlot(cluster.averages, genes.plot = markers.to.plot_1, plot.legend = T, x.lab.rot = T, scale.by = "size", col.max = 3, col.min=-3.0)
DoHeatmap(object = cluster.averages, genes.use = markers.to.plot,  
  group.label.rot = TRUE, use.scaled = T, group.cex=0,group.order = c("Astrocyte","Microglia","ODC","OPC","In1A","In1b","In1c","In3","In4A","In4B","In5","In6A","In6B","In8","Ex1","Ex2","Ex3", "Ex4","Ex5a","Ex5b","Ex6A","Ex6b","Ex8"))

```


# Subset Excitatroy and Inhibitory neurons, scaled and centered and re ran negbinom differential expression
```{r}
Excitatory_0.8_clustermarkers <-  FindAllMarkers(object = Excitatory, only.pos = T, min.pct = 0.25, thresh.use = 0.25, test.use="negbinom", logfc.threshold = 0.25)
write.table(Excitatory_0.8_clustermarkers, file="./Excitatory_0.8_clusters_DEG_2019.txt",sep="\t",quote=F)

Inhibitory_0.8_clustermarkers <-  FindAllMarkers(object = Inhibitory, only.pos = T, min.pct = 0.25, thresh.use = 0.25, test.use="negbinom", logfc.threshold = 0.25)
write.table(Inhibitory_0.8_clustermarkers, file="./Inhibitory_0.8_clusters_DEG_2019.txt",sep="\t",quote=F)
```

